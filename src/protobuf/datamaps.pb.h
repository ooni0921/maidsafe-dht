// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_datamaps_2eproto__INCLUDED
#define PROTOBUF_datamaps_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace maidsafe {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_datamaps_2eproto();
void protobuf_BuildDesc_datamaps_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class Key;
class DataMap;
class MetaDataMap;
class MetaData;
class Chunk;
class ShareFromMe;
class ShareToMe;
class ShareToMeBufferMessage;
class DataAtlas;

enum itemtype {
  REGULAR_FILE = 0,
  SMALL_FILE = 1,
  EMPTY_FILE = 2,
  LOCKED_FILE = 3,
  DIRECTORY = 4,
  EMPTY_DIRECTORY = 5,
  LINK = 6,
  NOT_FOR_PROCESSING = 7,
  UNKNOWN = 8
};
const ::google::protobuf::EnumDescriptor* itemtype_descriptor();
bool itemtype_IsValid(int value);
const itemtype itemtype_MIN = REGULAR_FILE;
const itemtype itemtype_MAX = UNKNOWN;

enum ShareOperation {
  SHARE_ADD = 0,
  SHARE_REMOVE = 1,
  SHARE_ADD_ITEM = 2,
  SHARE_DEL_ITEM = 3
};
const ::google::protobuf::EnumDescriptor* ShareOperation_descriptor();
bool ShareOperation_IsValid(int value);
const ShareOperation ShareOperation_MIN = SHARE_ADD;
const ShareOperation ShareOperation_MAX = SHARE_DEL_ITEM;

enum PacketType {
  ANMID = 0,
  ANTMID = 1,
  ANSMID = 2,
  MAID = 3,
  PMID = 4,
  ANMPID = 5,
  MPID = 6
};
const ::google::protobuf::EnumDescriptor* PacketType_descriptor();
bool PacketType_IsValid(int value);
const PacketType PacketType_MIN = ANMID;
const PacketType PacketType_MAX = MPID;

// ===================================================================

class Key : public ::google::protobuf::Message {
 public:
  Key();
  virtual ~Key();
  
  Key(const Key& from);
  
  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Key& default_instance();
  void Swap(Key* other);
  
  // implements Message ----------------------------------------------
  
  Key* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
  // required .maidsafe.PacketType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  inline maidsafe::PacketType type() const;
  inline void set_type(maidsafe::PacketType value);
  
  // required bytes private_key = 3;
  inline bool has_private_key() const;
  inline void clear_private_key();
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  int type_;
  ::std::string* private_key_;
  static const ::std::string _default_private_key_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  friend void protobuf_BuildDesc_datamaps_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Key* default_instance_;
};
// -------------------------------------------------------------------

class DataMap : public ::google::protobuf::Message {
 public:
  DataMap();
  virtual ~DataMap();
  
  DataMap(const DataMap& from);
  
  inline DataMap& operator=(const DataMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMap& default_instance();
  void Swap(DataMap* other);
  
  // implements Message ----------------------------------------------
  
  DataMap* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes file_hash = 1;
  inline bool has_file_hash() const;
  inline void clear_file_hash();
  inline const ::std::string& file_hash() const;
  inline void set_file_hash(const ::std::string& value);
  inline void set_file_hash(const char* value);
  inline void set_file_hash(const void* value, size_t size);
  inline ::std::string* mutable_file_hash();
  
  // optional bytes se_version = 2;
  inline bool has_se_version() const;
  inline void clear_se_version();
  inline const ::std::string& se_version() const;
  inline void set_se_version(const ::std::string& value);
  inline void set_se_version(const char* value);
  inline void set_se_version(const void* value, size_t size);
  inline ::std::string* mutable_se_version();
  
  // repeated bytes chunk_name = 3;
  inline int chunk_name_size() const;
  inline void clear_chunk_name();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& chunk_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_chunk_name();
  inline const ::std::string& chunk_name(int index) const;
  inline ::std::string* mutable_chunk_name(int index);
  inline void set_chunk_name(int index, const ::std::string& value);
  inline void set_chunk_name(int index, const char* value);
  inline ::std::string* add_chunk_name();
  inline void add_chunk_name(const ::std::string& value);
  inline void add_chunk_name(const char* value);
  inline void set_chunk_name(int index, const void* value, size_t size);
  inline void add_chunk_name(const void* value, size_t size);
  
  // repeated bytes encrypted_chunk_name = 4;
  inline int encrypted_chunk_name_size() const;
  inline void clear_encrypted_chunk_name();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& encrypted_chunk_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_encrypted_chunk_name();
  inline const ::std::string& encrypted_chunk_name(int index) const;
  inline ::std::string* mutable_encrypted_chunk_name(int index);
  inline void set_encrypted_chunk_name(int index, const ::std::string& value);
  inline void set_encrypted_chunk_name(int index, const char* value);
  inline ::std::string* add_encrypted_chunk_name();
  inline void add_encrypted_chunk_name(const ::std::string& value);
  inline void add_encrypted_chunk_name(const char* value);
  inline void set_encrypted_chunk_name(int index, const void* value, size_t size);
  inline void add_encrypted_chunk_name(const void* value, size_t size);
  
  // repeated uint64 chunk_size = 5;
  inline int chunk_size_size() const;
  inline void clear_chunk_size();
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >& chunk_size() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >* mutable_chunk_size();
  inline ::google::protobuf::uint64 chunk_size(int index) const;
  inline void set_chunk_size(int index, ::google::protobuf::uint64 value);
  inline void add_chunk_size(::google::protobuf::uint64 value);
  
  // optional bool compression_on = 6 [default = false];
  inline bool has_compression_on() const;
  inline void clear_compression_on();
  inline bool compression_on() const;
  inline void set_compression_on(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_hash_;
  static const ::std::string _default_file_hash_;
  ::std::string* se_version_;
  static const ::std::string _default_se_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> chunk_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> encrypted_chunk_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > chunk_size_;
  bool compression_on_;
  friend void protobuf_BuildDesc_datamaps_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DataMap* default_instance_;
};
// -------------------------------------------------------------------

class MetaDataMap : public ::google::protobuf::Message {
 public:
  MetaDataMap();
  virtual ~MetaDataMap();
  
  MetaDataMap(const MetaDataMap& from);
  
  inline MetaDataMap& operator=(const MetaDataMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaDataMap& default_instance();
  void Swap(MetaDataMap* other);
  
  // implements Message ----------------------------------------------
  
  MetaDataMap* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required bytes display_name = 2;
  inline bool has_display_name() const;
  inline void clear_display_name();
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const void* value, size_t size);
  inline ::std::string* mutable_display_name();
  
  // required .maidsafe.itemtype type = 3;
  inline bool has_type() const;
  inline void clear_type();
  inline maidsafe::itemtype type() const;
  inline void set_type(maidsafe::itemtype value);
  
  // repeated bytes file_hash = 4;
  inline int file_hash_size() const;
  inline void clear_file_hash();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& file_hash() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_file_hash();
  inline const ::std::string& file_hash(int index) const;
  inline ::std::string* mutable_file_hash(int index);
  inline void set_file_hash(int index, const ::std::string& value);
  inline void set_file_hash(int index, const char* value);
  inline ::std::string* add_file_hash();
  inline void add_file_hash(const ::std::string& value);
  inline void add_file_hash(const char* value);
  inline void set_file_hash(int index, const void* value, size_t size);
  inline void add_file_hash(const void* value, size_t size);
  
  // optional bytes stats = 5;
  inline bool has_stats() const;
  inline void clear_stats();
  inline const ::std::string& stats() const;
  inline void set_stats(const ::std::string& value);
  inline void set_stats(const char* value);
  inline void set_stats(const void* value, size_t size);
  inline ::std::string* mutable_stats();
  
  // optional bytes tag = 6;
  inline bool has_tag() const;
  inline void clear_tag();
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  
  // optional int32 file_size_high = 7;
  inline bool has_file_size_high() const;
  inline void clear_file_size_high();
  inline ::google::protobuf::int32 file_size_high() const;
  inline void set_file_size_high(::google::protobuf::int32 value);
  
  // optional int32 file_size_low = 8;
  inline bool has_file_size_low() const;
  inline void clear_file_size_low();
  inline ::google::protobuf::int32 file_size_low() const;
  inline void set_file_size_low(::google::protobuf::int32 value);
  
  // optional int32 creation_time = 9;
  inline bool has_creation_time() const;
  inline void clear_creation_time();
  inline ::google::protobuf::int32 creation_time() const;
  inline void set_creation_time(::google::protobuf::int32 value);
  
  // optional int32 last_modified = 10;
  inline bool has_last_modified() const;
  inline void clear_last_modified();
  inline ::google::protobuf::int32 last_modified() const;
  inline void set_last_modified(::google::protobuf::int32 value);
  
  // optional int32 last_access = 11;
  inline bool has_last_access() const;
  inline void clear_last_access();
  inline ::google::protobuf::int32 last_access() const;
  inline void set_last_access(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::std::string* display_name_;
  static const ::std::string _default_display_name_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> file_hash_;
  ::std::string* stats_;
  static const ::std::string _default_stats_;
  ::std::string* tag_;
  static const ::std::string _default_tag_;
  ::google::protobuf::int32 file_size_high_;
  ::google::protobuf::int32 file_size_low_;
  ::google::protobuf::int32 creation_time_;
  ::google::protobuf::int32 last_modified_;
  ::google::protobuf::int32 last_access_;
  friend void protobuf_BuildDesc_datamaps_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MetaDataMap* default_instance_;
};
// -------------------------------------------------------------------

class MetaData : public ::google::protobuf::Message {
 public:
  MetaData();
  virtual ~MetaData();
  
  MetaData(const MetaData& from);
  
  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaData& default_instance();
  void Swap(MetaData* other);
  
  // implements Message ----------------------------------------------
  
  MetaData* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes ms_path = 1;
  inline bool has_ms_path() const;
  inline void clear_ms_path();
  inline const ::std::string& ms_path() const;
  inline void set_ms_path(const ::std::string& value);
  inline void set_ms_path(const char* value);
  inline void set_ms_path(const void* value, size_t size);
  inline ::std::string* mutable_ms_path();
  
  // required bytes file_hash = 2;
  inline bool has_file_hash() const;
  inline void clear_file_hash();
  inline const ::std::string& file_hash() const;
  inline void set_file_hash(const ::std::string& value);
  inline void set_file_hash(const char* value);
  inline void set_file_hash(const void* value, size_t size);
  inline ::std::string* mutable_file_hash();
  
  // optional bytes stats = 3;
  inline bool has_stats() const;
  inline void clear_stats();
  inline const ::std::string& stats() const;
  inline void set_stats(const ::std::string& value);
  inline void set_stats(const char* value);
  inline void set_stats(const void* value, size_t size);
  inline ::std::string* mutable_stats();
  
  // optional int32 file_size = 4;
  inline bool has_file_size() const;
  inline void clear_file_size();
  inline ::google::protobuf::int32 file_size() const;
  inline void set_file_size(::google::protobuf::int32 value);
  
  // optional bytes outname = 5;
  inline bool has_outname() const;
  inline void clear_outname();
  inline const ::std::string& outname() const;
  inline void set_outname(const ::std::string& value);
  inline void set_outname(const char* value);
  inline void set_outname(const void* value, size_t size);
  inline ::std::string* mutable_outname();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* ms_path_;
  static const ::std::string _default_ms_path_;
  ::std::string* file_hash_;
  static const ::std::string _default_file_hash_;
  ::std::string* stats_;
  static const ::std::string _default_stats_;
  ::google::protobuf::int32 file_size_;
  ::std::string* outname_;
  static const ::std::string _default_outname_;
  friend void protobuf_BuildDesc_datamaps_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MetaData* default_instance_;
};
// -------------------------------------------------------------------

class Chunk : public ::google::protobuf::Message {
 public:
  Chunk();
  virtual ~Chunk();
  
  Chunk(const Chunk& from);
  
  inline Chunk& operator=(const Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chunk& default_instance();
  void Swap(Chunk* other);
  
  // implements Message ----------------------------------------------
  
  Chunk* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes compression_type = 1;
  inline bool has_compression_type() const;
  inline void clear_compression_type();
  inline const ::std::string& compression_type() const;
  inline void set_compression_type(const ::std::string& value);
  inline void set_compression_type(const char* value);
  inline void set_compression_type(const void* value, size_t size);
  inline ::std::string* mutable_compression_type();
  
  // repeated bytes chunklet = 2;
  inline int chunklet_size() const;
  inline void clear_chunklet();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& chunklet() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_chunklet();
  inline const ::std::string& chunklet(int index) const;
  inline ::std::string* mutable_chunklet(int index);
  inline void set_chunklet(int index, const ::std::string& value);
  inline void set_chunklet(int index, const char* value);
  inline ::std::string* add_chunklet();
  inline void add_chunklet(const ::std::string& value);
  inline void add_chunklet(const char* value);
  inline void set_chunklet(int index, const void* value, size_t size);
  inline void add_chunklet(const void* value, size_t size);
  
  // repeated int32 pre_compression_chunklet_size_ = 3;
  inline int pre_compression_chunklet_size__size() const;
  inline void clear_pre_compression_chunklet_size_();
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >& pre_compression_chunklet_size_() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >* mutable_pre_compression_chunklet_size_();
  inline ::google::protobuf::int32 pre_compression_chunklet_size_(int index) const;
  inline void set_pre_compression_chunklet_size_(int index, ::google::protobuf::int32 value);
  inline void add_pre_compression_chunklet_size_(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* compression_type_;
  static const ::std::string _default_compression_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> chunklet_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pre_compression_chunklet_size__;
  friend void protobuf_BuildDesc_datamaps_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Chunk* default_instance_;
};
// -------------------------------------------------------------------

class ShareFromMe : public ::google::protobuf::Message {
 public:
  ShareFromMe();
  virtual ~ShareFromMe();
  
  ShareFromMe(const ShareFromMe& from);
  
  inline ShareFromMe& operator=(const ShareFromMe& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareFromMe& default_instance();
  void Swap(ShareFromMe* other);
  
  // implements Message ----------------------------------------------
  
  ShareFromMe* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 share_id = 1;
  inline bool has_share_id() const;
  inline void clear_share_id();
  inline ::google::protobuf::int32 share_id() const;
  inline void set_share_id(::google::protobuf::int32 value);
  
  // required bytes share_name = 2;
  inline bool has_share_name() const;
  inline void clear_share_name();
  inline const ::std::string& share_name() const;
  inline void set_share_name(const ::std::string& value);
  inline void set_share_name(const char* value);
  inline void set_share_name(const void* value, size_t size);
  inline ::std::string* mutable_share_name();
  
  // optional bytes owner = 3;
  inline bool has_owner() const;
  inline void clear_owner();
  inline const ::std::string& owner() const;
  inline void set_owner(const ::std::string& value);
  inline void set_owner(const char* value);
  inline void set_owner(const void* value, size_t size);
  inline ::std::string* mutable_owner();
  
  // repeated int32 meta_data_map_id = 4;
  inline int meta_data_map_id_size() const;
  inline void clear_meta_data_map_id();
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >& meta_data_map_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >* mutable_meta_data_map_id();
  inline ::google::protobuf::int32 meta_data_map_id(int index) const;
  inline void set_meta_data_map_id(int index, ::google::protobuf::int32 value);
  inline void add_meta_data_map_id(::google::protobuf::int32 value);
  
  // repeated bytes users = 5;
  inline int users_size() const;
  inline void clear_users();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& users() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_users();
  inline const ::std::string& users(int index) const;
  inline ::std::string* mutable_users(int index);
  inline void set_users(int index, const ::std::string& value);
  inline void set_users(int index, const char* value);
  inline ::std::string* add_users();
  inline void add_users(const ::std::string& value);
  inline void add_users(const char* value);
  inline void set_users(int index, const void* value, size_t size);
  inline void add_users(const void* value, size_t size);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 share_id_;
  ::std::string* share_name_;
  static const ::std::string _default_share_name_;
  ::std::string* owner_;
  static const ::std::string _default_owner_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > meta_data_map_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> users_;
  friend void protobuf_BuildDesc_datamaps_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ShareFromMe* default_instance_;
};
// -------------------------------------------------------------------

class ShareToMe : public ::google::protobuf::Message {
 public:
  ShareToMe();
  virtual ~ShareToMe();
  
  ShareToMe(const ShareToMe& from);
  
  inline ShareToMe& operator=(const ShareToMe& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareToMe& default_instance();
  void Swap(ShareToMe* other);
  
  // implements Message ----------------------------------------------
  
  ShareToMe* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 share_id = 1;
  inline bool has_share_id() const;
  inline void clear_share_id();
  inline ::google::protobuf::int32 share_id() const;
  inline void set_share_id(::google::protobuf::int32 value);
  
  // required bytes share_name = 2;
  inline bool has_share_name() const;
  inline void clear_share_name();
  inline const ::std::string& share_name() const;
  inline void set_share_name(const ::std::string& value);
  inline void set_share_name(const char* value);
  inline void set_share_name(const void* value, size_t size);
  inline ::std::string* mutable_share_name();
  
  // required bytes owner = 3;
  inline bool has_owner() const;
  inline void clear_owner();
  inline const ::std::string& owner() const;
  inline void set_owner(const ::std::string& value);
  inline void set_owner(const char* value);
  inline void set_owner(const void* value, size_t size);
  inline ::std::string* mutable_owner();
  
  // repeated .maidsafe.MetaDataMap mdms = 4;
  inline int mdms_size() const;
  inline void clear_mdms();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >& mdms() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >* mutable_mdms();
  inline const ::maidsafe::MetaDataMap& mdms(int index) const;
  inline ::maidsafe::MetaDataMap* mutable_mdms(int index);
  inline ::maidsafe::MetaDataMap* add_mdms();
  
  // repeated .maidsafe.DataMap dms = 5;
  inline int dms_size() const;
  inline void clear_dms();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >& dms() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >* mutable_dms();
  inline const ::maidsafe::DataMap& dms(int index) const;
  inline ::maidsafe::DataMap* mutable_dms(int index);
  inline ::maidsafe::DataMap* add_dms();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 share_id_;
  ::std::string* share_name_;
  static const ::std::string _default_share_name_;
  ::std::string* owner_;
  static const ::std::string _default_owner_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap > mdms_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap > dms_;
  friend void protobuf_BuildDesc_datamaps_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ShareToMe* default_instance_;
};
// -------------------------------------------------------------------

class ShareToMeBufferMessage : public ::google::protobuf::Message {
 public:
  ShareToMeBufferMessage();
  virtual ~ShareToMeBufferMessage();
  
  ShareToMeBufferMessage(const ShareToMeBufferMessage& from);
  
  inline ShareToMeBufferMessage& operator=(const ShareToMeBufferMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareToMeBufferMessage& default_instance();
  void Swap(ShareToMeBufferMessage* other);
  
  // implements Message ----------------------------------------------
  
  ShareToMeBufferMessage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 share_id = 1;
  inline bool has_share_id() const;
  inline void clear_share_id();
  inline ::google::protobuf::int32 share_id() const;
  inline void set_share_id(::google::protobuf::int32 value);
  
  // optional bytes share_name = 2;
  inline bool has_share_name() const;
  inline void clear_share_name();
  inline const ::std::string& share_name() const;
  inline void set_share_name(const ::std::string& value);
  inline void set_share_name(const char* value);
  inline void set_share_name(const void* value, size_t size);
  inline ::std::string* mutable_share_name();
  
  // required bytes owner = 3;
  inline bool has_owner() const;
  inline void clear_owner();
  inline const ::std::string& owner() const;
  inline void set_owner(const ::std::string& value);
  inline void set_owner(const char* value);
  inline void set_owner(const void* value, size_t size);
  inline ::std::string* mutable_owner();
  
  // required .maidsafe.ShareOperation op = 4;
  inline bool has_op() const;
  inline void clear_op();
  inline maidsafe::ShareOperation op() const;
  inline void set_op(maidsafe::ShareOperation value);
  
  // repeated .maidsafe.MetaDataMap mdms = 5;
  inline int mdms_size() const;
  inline void clear_mdms();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >& mdms() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >* mutable_mdms();
  inline const ::maidsafe::MetaDataMap& mdms(int index) const;
  inline ::maidsafe::MetaDataMap* mutable_mdms(int index);
  inline ::maidsafe::MetaDataMap* add_mdms();
  
  // repeated .maidsafe.DataMap dms = 6;
  inline int dms_size() const;
  inline void clear_dms();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >& dms() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >* mutable_dms();
  inline const ::maidsafe::DataMap& dms(int index) const;
  inline ::maidsafe::DataMap* mutable_dms(int index);
  inline ::maidsafe::DataMap* add_dms();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 share_id_;
  ::std::string* share_name_;
  static const ::std::string _default_share_name_;
  ::std::string* owner_;
  static const ::std::string _default_owner_;
  int op_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap > mdms_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap > dms_;
  friend void protobuf_BuildDesc_datamaps_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ShareToMeBufferMessage* default_instance_;
};
// -------------------------------------------------------------------

class DataAtlas : public ::google::protobuf::Message {
 public:
  DataAtlas();
  virtual ~DataAtlas();
  
  DataAtlas(const DataAtlas& from);
  
  inline DataAtlas& operator=(const DataAtlas& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataAtlas& default_instance();
  void Swap(DataAtlas* other);
  
  // implements Message ----------------------------------------------
  
  DataAtlas* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes root_db_key = 1;
  inline bool has_root_db_key() const;
  inline void clear_root_db_key();
  inline const ::std::string& root_db_key() const;
  inline void set_root_db_key(const ::std::string& value);
  inline void set_root_db_key(const char* value);
  inline void set_root_db_key(const void* value, size_t size);
  inline ::std::string* mutable_root_db_key();
  
  // repeated .maidsafe.Key keys = 2;
  inline int keys_size() const;
  inline void clear_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >* mutable_keys();
  inline const ::maidsafe::Key& keys(int index) const;
  inline ::maidsafe::Key* mutable_keys(int index);
  inline ::maidsafe::Key* add_keys();
  
  // repeated .maidsafe.MetaDataMap mdms = 3;
  inline int mdms_size() const;
  inline void clear_mdms();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >& mdms() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >* mutable_mdms();
  inline const ::maidsafe::MetaDataMap& mdms(int index) const;
  inline ::maidsafe::MetaDataMap* mutable_mdms(int index);
  inline ::maidsafe::MetaDataMap* add_mdms();
  
  // repeated .maidsafe.DataMap dms = 4;
  inline int dms_size() const;
  inline void clear_dms();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >& dms() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >* mutable_dms();
  inline const ::maidsafe::DataMap& dms(int index) const;
  inline ::maidsafe::DataMap* mutable_dms(int index);
  inline ::maidsafe::DataMap* add_dms();
  
  // repeated .maidsafe.ShareFromMe offered_share = 5;
  inline int offered_share_size() const;
  inline void clear_offered_share();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareFromMe >& offered_share() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareFromMe >* mutable_offered_share();
  inline const ::maidsafe::ShareFromMe& offered_share(int index) const;
  inline ::maidsafe::ShareFromMe* mutable_offered_share(int index);
  inline ::maidsafe::ShareFromMe* add_offered_share();
  
  // repeated .maidsafe.ShareToMe accepted_share = 6;
  inline int accepted_share_size() const;
  inline void clear_accepted_share();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareToMe >& accepted_share() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareToMe >* mutable_accepted_share();
  inline const ::maidsafe::ShareToMe& accepted_share(int index) const;
  inline ::maidsafe::ShareToMe* mutable_accepted_share(int index);
  inline ::maidsafe::ShareToMe* add_accepted_share();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* root_db_key_;
  static const ::std::string _default_root_db_key_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::Key > keys_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap > mdms_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap > dms_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareFromMe > offered_share_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareToMe > accepted_share_;
  friend void protobuf_BuildDesc_datamaps_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DataAtlas* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// Key

// required bytes id = 1;
inline bool Key::has_id() const {
  return _has_bit(0);
}
inline void Key::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Key::id() const {
  return *id_;
}
inline void Key::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Key::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Key::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// required .maidsafe.PacketType type = 2;
inline bool Key::has_type() const {
  return _has_bit(1);
}
inline void Key::clear_type() {
  type_ = 0;
  _clear_bit(1);
}
inline maidsafe::PacketType Key::type() const {
  return static_cast< maidsafe::PacketType >(type_);
}
inline void Key::set_type(maidsafe::PacketType value) {
  GOOGLE_DCHECK(maidsafe::PacketType_IsValid(value));
  _set_bit(1);
  type_ = value;
}

// required bytes private_key = 3;
inline bool Key::has_private_key() const {
  return _has_bit(2);
}
inline void Key::clear_private_key() {
  if (private_key_ != &_default_private_key_) {
    private_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Key::private_key() const {
  return *private_key_;
}
inline void Key::set_private_key(const ::std::string& value) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Key::set_private_key(const char* value) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Key::set_private_key(const void* value, size_t size) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_private_key() {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}

// required bytes public_key = 4;
inline bool Key::has_public_key() const {
  return _has_bit(3);
}
inline void Key::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Key::public_key() const {
  return *public_key_;
}
inline void Key::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Key::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Key::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// -------------------------------------------------------------------

// DataMap

// required bytes file_hash = 1;
inline bool DataMap::has_file_hash() const {
  return _has_bit(0);
}
inline void DataMap::clear_file_hash() {
  if (file_hash_ != &_default_file_hash_) {
    file_hash_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DataMap::file_hash() const {
  return *file_hash_;
}
inline void DataMap::set_file_hash(const ::std::string& value) {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(value);
}
inline void DataMap::set_file_hash(const char* value) {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(value);
}
inline void DataMap::set_file_hash(const void* value, size_t size) {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMap::mutable_file_hash() {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  return file_hash_;
}

// optional bytes se_version = 2;
inline bool DataMap::has_se_version() const {
  return _has_bit(1);
}
inline void DataMap::clear_se_version() {
  if (se_version_ != &_default_se_version_) {
    se_version_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DataMap::se_version() const {
  return *se_version_;
}
inline void DataMap::set_se_version(const ::std::string& value) {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  se_version_->assign(value);
}
inline void DataMap::set_se_version(const char* value) {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  se_version_->assign(value);
}
inline void DataMap::set_se_version(const void* value, size_t size) {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  se_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMap::mutable_se_version() {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  return se_version_;
}

// repeated bytes chunk_name = 3;
inline int DataMap::chunk_name_size() const {
  return chunk_name_.size();
}
inline void DataMap::clear_chunk_name() {
  chunk_name_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataMap::chunk_name() const {
  return chunk_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataMap::mutable_chunk_name() {
  return &chunk_name_;
}
inline const ::std::string& DataMap::chunk_name(int index) const {
  return chunk_name_.Get(index);
}
inline ::std::string* DataMap::mutable_chunk_name(int index) {
  return chunk_name_.Mutable(index);
}
inline void DataMap::set_chunk_name(int index, const ::std::string& value) {
  chunk_name_.Mutable(index)->assign(value);
}
inline void DataMap::set_chunk_name(int index, const char* value) {
  chunk_name_.Mutable(index)->assign(value);
}
inline ::std::string* DataMap::add_chunk_name() {
  return chunk_name_.Add();
}
inline void DataMap::add_chunk_name(const ::std::string& value) {
  chunk_name_.Add()->assign(value);
}
inline void DataMap::add_chunk_name(const char* value) {
  chunk_name_.Add()->assign(value);
}
inline void DataMap::set_chunk_name(int index, const void* value, size_t size) {
  chunk_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void DataMap::add_chunk_name(const void* value, size_t size) {
  chunk_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated bytes encrypted_chunk_name = 4;
inline int DataMap::encrypted_chunk_name_size() const {
  return encrypted_chunk_name_.size();
}
inline void DataMap::clear_encrypted_chunk_name() {
  encrypted_chunk_name_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataMap::encrypted_chunk_name() const {
  return encrypted_chunk_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataMap::mutable_encrypted_chunk_name() {
  return &encrypted_chunk_name_;
}
inline const ::std::string& DataMap::encrypted_chunk_name(int index) const {
  return encrypted_chunk_name_.Get(index);
}
inline ::std::string* DataMap::mutable_encrypted_chunk_name(int index) {
  return encrypted_chunk_name_.Mutable(index);
}
inline void DataMap::set_encrypted_chunk_name(int index, const ::std::string& value) {
  encrypted_chunk_name_.Mutable(index)->assign(value);
}
inline void DataMap::set_encrypted_chunk_name(int index, const char* value) {
  encrypted_chunk_name_.Mutable(index)->assign(value);
}
inline ::std::string* DataMap::add_encrypted_chunk_name() {
  return encrypted_chunk_name_.Add();
}
inline void DataMap::add_encrypted_chunk_name(const ::std::string& value) {
  encrypted_chunk_name_.Add()->assign(value);
}
inline void DataMap::add_encrypted_chunk_name(const char* value) {
  encrypted_chunk_name_.Add()->assign(value);
}
inline void DataMap::set_encrypted_chunk_name(int index, const void* value, size_t size) {
  encrypted_chunk_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void DataMap::add_encrypted_chunk_name(const void* value, size_t size) {
  encrypted_chunk_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated uint64 chunk_size = 5;
inline int DataMap::chunk_size_size() const {
  return chunk_size_.size();
}
inline void DataMap::clear_chunk_size() {
  chunk_size_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DataMap::chunk_size() const {
  return chunk_size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DataMap::mutable_chunk_size() {
  return &chunk_size_;
}
inline ::google::protobuf::uint64 DataMap::chunk_size(int index) const {
  return chunk_size_.Get(index);
}
inline void DataMap::set_chunk_size(int index, ::google::protobuf::uint64 value) {
  chunk_size_.Set(index, value);
}
inline void DataMap::add_chunk_size(::google::protobuf::uint64 value) {
  chunk_size_.Add(value);
}

// optional bool compression_on = 6 [default = false];
inline bool DataMap::has_compression_on() const {
  return _has_bit(5);
}
inline void DataMap::clear_compression_on() {
  compression_on_ = false;
  _clear_bit(5);
}
inline bool DataMap::compression_on() const {
  return compression_on_;
}
inline void DataMap::set_compression_on(bool value) {
  _set_bit(5);
  compression_on_ = value;
}

// -------------------------------------------------------------------

// MetaDataMap

// required int32 id = 1;
inline bool MetaDataMap::has_id() const {
  return _has_bit(0);
}
inline void MetaDataMap::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MetaDataMap::id() const {
  return id_;
}
inline void MetaDataMap::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// required bytes display_name = 2;
inline bool MetaDataMap::has_display_name() const {
  return _has_bit(1);
}
inline void MetaDataMap::clear_display_name() {
  if (display_name_ != &_default_display_name_) {
    display_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MetaDataMap::display_name() const {
  return *display_name_;
}
inline void MetaDataMap::set_display_name(const ::std::string& value) {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void MetaDataMap::set_display_name(const char* value) {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void MetaDataMap::set_display_name(const void* value, size_t size) {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::mutable_display_name() {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}

// required .maidsafe.itemtype type = 3;
inline bool MetaDataMap::has_type() const {
  return _has_bit(2);
}
inline void MetaDataMap::clear_type() {
  type_ = 0;
  _clear_bit(2);
}
inline maidsafe::itemtype MetaDataMap::type() const {
  return static_cast< maidsafe::itemtype >(type_);
}
inline void MetaDataMap::set_type(maidsafe::itemtype value) {
  GOOGLE_DCHECK(maidsafe::itemtype_IsValid(value));
  _set_bit(2);
  type_ = value;
}

// repeated bytes file_hash = 4;
inline int MetaDataMap::file_hash_size() const {
  return file_hash_.size();
}
inline void MetaDataMap::clear_file_hash() {
  file_hash_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MetaDataMap::file_hash() const {
  return file_hash_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MetaDataMap::mutable_file_hash() {
  return &file_hash_;
}
inline const ::std::string& MetaDataMap::file_hash(int index) const {
  return file_hash_.Get(index);
}
inline ::std::string* MetaDataMap::mutable_file_hash(int index) {
  return file_hash_.Mutable(index);
}
inline void MetaDataMap::set_file_hash(int index, const ::std::string& value) {
  file_hash_.Mutable(index)->assign(value);
}
inline void MetaDataMap::set_file_hash(int index, const char* value) {
  file_hash_.Mutable(index)->assign(value);
}
inline ::std::string* MetaDataMap::add_file_hash() {
  return file_hash_.Add();
}
inline void MetaDataMap::add_file_hash(const ::std::string& value) {
  file_hash_.Add()->assign(value);
}
inline void MetaDataMap::add_file_hash(const char* value) {
  file_hash_.Add()->assign(value);
}
inline void MetaDataMap::set_file_hash(int index, const void* value, size_t size) {
  file_hash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void MetaDataMap::add_file_hash(const void* value, size_t size) {
  file_hash_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// optional bytes stats = 5;
inline bool MetaDataMap::has_stats() const {
  return _has_bit(4);
}
inline void MetaDataMap::clear_stats() {
  if (stats_ != &_default_stats_) {
    stats_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MetaDataMap::stats() const {
  return *stats_;
}
inline void MetaDataMap::set_stats(const ::std::string& value) {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(value);
}
inline void MetaDataMap::set_stats(const char* value) {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(value);
}
inline void MetaDataMap::set_stats(const void* value, size_t size) {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::mutable_stats() {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  return stats_;
}

// optional bytes tag = 6;
inline bool MetaDataMap::has_tag() const {
  return _has_bit(5);
}
inline void MetaDataMap::clear_tag() {
  if (tag_ != &_default_tag_) {
    tag_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& MetaDataMap::tag() const {
  return *tag_;
}
inline void MetaDataMap::set_tag(const ::std::string& value) {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void MetaDataMap::set_tag(const char* value) {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void MetaDataMap::set_tag(const void* value, size_t size) {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::mutable_tag() {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  return tag_;
}

// optional int32 file_size_high = 7;
inline bool MetaDataMap::has_file_size_high() const {
  return _has_bit(6);
}
inline void MetaDataMap::clear_file_size_high() {
  file_size_high_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 MetaDataMap::file_size_high() const {
  return file_size_high_;
}
inline void MetaDataMap::set_file_size_high(::google::protobuf::int32 value) {
  _set_bit(6);
  file_size_high_ = value;
}

// optional int32 file_size_low = 8;
inline bool MetaDataMap::has_file_size_low() const {
  return _has_bit(7);
}
inline void MetaDataMap::clear_file_size_low() {
  file_size_low_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 MetaDataMap::file_size_low() const {
  return file_size_low_;
}
inline void MetaDataMap::set_file_size_low(::google::protobuf::int32 value) {
  _set_bit(7);
  file_size_low_ = value;
}

// optional int32 creation_time = 9;
inline bool MetaDataMap::has_creation_time() const {
  return _has_bit(8);
}
inline void MetaDataMap::clear_creation_time() {
  creation_time_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 MetaDataMap::creation_time() const {
  return creation_time_;
}
inline void MetaDataMap::set_creation_time(::google::protobuf::int32 value) {
  _set_bit(8);
  creation_time_ = value;
}

// optional int32 last_modified = 10;
inline bool MetaDataMap::has_last_modified() const {
  return _has_bit(9);
}
inline void MetaDataMap::clear_last_modified() {
  last_modified_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 MetaDataMap::last_modified() const {
  return last_modified_;
}
inline void MetaDataMap::set_last_modified(::google::protobuf::int32 value) {
  _set_bit(9);
  last_modified_ = value;
}

// optional int32 last_access = 11;
inline bool MetaDataMap::has_last_access() const {
  return _has_bit(10);
}
inline void MetaDataMap::clear_last_access() {
  last_access_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 MetaDataMap::last_access() const {
  return last_access_;
}
inline void MetaDataMap::set_last_access(::google::protobuf::int32 value) {
  _set_bit(10);
  last_access_ = value;
}

// -------------------------------------------------------------------

// MetaData

// required bytes ms_path = 1;
inline bool MetaData::has_ms_path() const {
  return _has_bit(0);
}
inline void MetaData::clear_ms_path() {
  if (ms_path_ != &_default_ms_path_) {
    ms_path_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MetaData::ms_path() const {
  return *ms_path_;
}
inline void MetaData::set_ms_path(const ::std::string& value) {
  _set_bit(0);
  if (ms_path_ == &_default_ms_path_) {
    ms_path_ = new ::std::string;
  }
  ms_path_->assign(value);
}
inline void MetaData::set_ms_path(const char* value) {
  _set_bit(0);
  if (ms_path_ == &_default_ms_path_) {
    ms_path_ = new ::std::string;
  }
  ms_path_->assign(value);
}
inline void MetaData::set_ms_path(const void* value, size_t size) {
  _set_bit(0);
  if (ms_path_ == &_default_ms_path_) {
    ms_path_ = new ::std::string;
  }
  ms_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_ms_path() {
  _set_bit(0);
  if (ms_path_ == &_default_ms_path_) {
    ms_path_ = new ::std::string;
  }
  return ms_path_;
}

// required bytes file_hash = 2;
inline bool MetaData::has_file_hash() const {
  return _has_bit(1);
}
inline void MetaData::clear_file_hash() {
  if (file_hash_ != &_default_file_hash_) {
    file_hash_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MetaData::file_hash() const {
  return *file_hash_;
}
inline void MetaData::set_file_hash(const ::std::string& value) {
  _set_bit(1);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(value);
}
inline void MetaData::set_file_hash(const char* value) {
  _set_bit(1);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(value);
}
inline void MetaData::set_file_hash(const void* value, size_t size) {
  _set_bit(1);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_file_hash() {
  _set_bit(1);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  return file_hash_;
}

// optional bytes stats = 3;
inline bool MetaData::has_stats() const {
  return _has_bit(2);
}
inline void MetaData::clear_stats() {
  if (stats_ != &_default_stats_) {
    stats_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& MetaData::stats() const {
  return *stats_;
}
inline void MetaData::set_stats(const ::std::string& value) {
  _set_bit(2);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(value);
}
inline void MetaData::set_stats(const char* value) {
  _set_bit(2);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(value);
}
inline void MetaData::set_stats(const void* value, size_t size) {
  _set_bit(2);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_stats() {
  _set_bit(2);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  return stats_;
}

// optional int32 file_size = 4;
inline bool MetaData::has_file_size() const {
  return _has_bit(3);
}
inline void MetaData::clear_file_size() {
  file_size_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 MetaData::file_size() const {
  return file_size_;
}
inline void MetaData::set_file_size(::google::protobuf::int32 value) {
  _set_bit(3);
  file_size_ = value;
}

// optional bytes outname = 5;
inline bool MetaData::has_outname() const {
  return _has_bit(4);
}
inline void MetaData::clear_outname() {
  if (outname_ != &_default_outname_) {
    outname_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MetaData::outname() const {
  return *outname_;
}
inline void MetaData::set_outname(const ::std::string& value) {
  _set_bit(4);
  if (outname_ == &_default_outname_) {
    outname_ = new ::std::string;
  }
  outname_->assign(value);
}
inline void MetaData::set_outname(const char* value) {
  _set_bit(4);
  if (outname_ == &_default_outname_) {
    outname_ = new ::std::string;
  }
  outname_->assign(value);
}
inline void MetaData::set_outname(const void* value, size_t size) {
  _set_bit(4);
  if (outname_ == &_default_outname_) {
    outname_ = new ::std::string;
  }
  outname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_outname() {
  _set_bit(4);
  if (outname_ == &_default_outname_) {
    outname_ = new ::std::string;
  }
  return outname_;
}

// -------------------------------------------------------------------

// Chunk

// optional bytes compression_type = 1;
inline bool Chunk::has_compression_type() const {
  return _has_bit(0);
}
inline void Chunk::clear_compression_type() {
  if (compression_type_ != &_default_compression_type_) {
    compression_type_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Chunk::compression_type() const {
  return *compression_type_;
}
inline void Chunk::set_compression_type(const ::std::string& value) {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  compression_type_->assign(value);
}
inline void Chunk::set_compression_type(const char* value) {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  compression_type_->assign(value);
}
inline void Chunk::set_compression_type(const void* value, size_t size) {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  compression_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chunk::mutable_compression_type() {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  return compression_type_;
}

// repeated bytes chunklet = 2;
inline int Chunk::chunklet_size() const {
  return chunklet_.size();
}
inline void Chunk::clear_chunklet() {
  chunklet_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chunk::chunklet() const {
  return chunklet_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chunk::mutable_chunklet() {
  return &chunklet_;
}
inline const ::std::string& Chunk::chunklet(int index) const {
  return chunklet_.Get(index);
}
inline ::std::string* Chunk::mutable_chunklet(int index) {
  return chunklet_.Mutable(index);
}
inline void Chunk::set_chunklet(int index, const ::std::string& value) {
  chunklet_.Mutable(index)->assign(value);
}
inline void Chunk::set_chunklet(int index, const char* value) {
  chunklet_.Mutable(index)->assign(value);
}
inline ::std::string* Chunk::add_chunklet() {
  return chunklet_.Add();
}
inline void Chunk::add_chunklet(const ::std::string& value) {
  chunklet_.Add()->assign(value);
}
inline void Chunk::add_chunklet(const char* value) {
  chunklet_.Add()->assign(value);
}
inline void Chunk::set_chunklet(int index, const void* value, size_t size) {
  chunklet_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void Chunk::add_chunklet(const void* value, size_t size) {
  chunklet_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated int32 pre_compression_chunklet_size_ = 3;
inline int Chunk::pre_compression_chunklet_size__size() const {
  return pre_compression_chunklet_size__.size();
}
inline void Chunk::clear_pre_compression_chunklet_size_() {
  pre_compression_chunklet_size__.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Chunk::pre_compression_chunklet_size_() const {
  return pre_compression_chunklet_size__;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Chunk::mutable_pre_compression_chunklet_size_() {
  return &pre_compression_chunklet_size__;
}
inline ::google::protobuf::int32 Chunk::pre_compression_chunklet_size_(int index) const {
  return pre_compression_chunklet_size__.Get(index);
}
inline void Chunk::set_pre_compression_chunklet_size_(int index, ::google::protobuf::int32 value) {
  pre_compression_chunklet_size__.Set(index, value);
}
inline void Chunk::add_pre_compression_chunklet_size_(::google::protobuf::int32 value) {
  pre_compression_chunklet_size__.Add(value);
}

// -------------------------------------------------------------------

// ShareFromMe

// required int32 share_id = 1;
inline bool ShareFromMe::has_share_id() const {
  return _has_bit(0);
}
inline void ShareFromMe::clear_share_id() {
  share_id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ShareFromMe::share_id() const {
  return share_id_;
}
inline void ShareFromMe::set_share_id(::google::protobuf::int32 value) {
  _set_bit(0);
  share_id_ = value;
}

// required bytes share_name = 2;
inline bool ShareFromMe::has_share_name() const {
  return _has_bit(1);
}
inline void ShareFromMe::clear_share_name() {
  if (share_name_ != &_default_share_name_) {
    share_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ShareFromMe::share_name() const {
  return *share_name_;
}
inline void ShareFromMe::set_share_name(const ::std::string& value) {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  share_name_->assign(value);
}
inline void ShareFromMe::set_share_name(const char* value) {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  share_name_->assign(value);
}
inline void ShareFromMe::set_share_name(const void* value, size_t size) {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  share_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareFromMe::mutable_share_name() {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  return share_name_;
}

// optional bytes owner = 3;
inline bool ShareFromMe::has_owner() const {
  return _has_bit(2);
}
inline void ShareFromMe::clear_owner() {
  if (owner_ != &_default_owner_) {
    owner_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ShareFromMe::owner() const {
  return *owner_;
}
inline void ShareFromMe::set_owner(const ::std::string& value) {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void ShareFromMe::set_owner(const char* value) {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void ShareFromMe::set_owner(const void* value, size_t size) {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareFromMe::mutable_owner() {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  return owner_;
}

// repeated int32 meta_data_map_id = 4;
inline int ShareFromMe::meta_data_map_id_size() const {
  return meta_data_map_id_.size();
}
inline void ShareFromMe::clear_meta_data_map_id() {
  meta_data_map_id_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ShareFromMe::meta_data_map_id() const {
  return meta_data_map_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ShareFromMe::mutable_meta_data_map_id() {
  return &meta_data_map_id_;
}
inline ::google::protobuf::int32 ShareFromMe::meta_data_map_id(int index) const {
  return meta_data_map_id_.Get(index);
}
inline void ShareFromMe::set_meta_data_map_id(int index, ::google::protobuf::int32 value) {
  meta_data_map_id_.Set(index, value);
}
inline void ShareFromMe::add_meta_data_map_id(::google::protobuf::int32 value) {
  meta_data_map_id_.Add(value);
}

// repeated bytes users = 5;
inline int ShareFromMe::users_size() const {
  return users_.size();
}
inline void ShareFromMe::clear_users() {
  users_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ShareFromMe::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ShareFromMe::mutable_users() {
  return &users_;
}
inline const ::std::string& ShareFromMe::users(int index) const {
  return users_.Get(index);
}
inline ::std::string* ShareFromMe::mutable_users(int index) {
  return users_.Mutable(index);
}
inline void ShareFromMe::set_users(int index, const ::std::string& value) {
  users_.Mutable(index)->assign(value);
}
inline void ShareFromMe::set_users(int index, const char* value) {
  users_.Mutable(index)->assign(value);
}
inline ::std::string* ShareFromMe::add_users() {
  return users_.Add();
}
inline void ShareFromMe::add_users(const ::std::string& value) {
  users_.Add()->assign(value);
}
inline void ShareFromMe::add_users(const char* value) {
  users_.Add()->assign(value);
}
inline void ShareFromMe::set_users(int index, const void* value, size_t size) {
  users_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void ShareFromMe::add_users(const void* value, size_t size) {
  users_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// -------------------------------------------------------------------

// ShareToMe

// required int32 share_id = 1;
inline bool ShareToMe::has_share_id() const {
  return _has_bit(0);
}
inline void ShareToMe::clear_share_id() {
  share_id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ShareToMe::share_id() const {
  return share_id_;
}
inline void ShareToMe::set_share_id(::google::protobuf::int32 value) {
  _set_bit(0);
  share_id_ = value;
}

// required bytes share_name = 2;
inline bool ShareToMe::has_share_name() const {
  return _has_bit(1);
}
inline void ShareToMe::clear_share_name() {
  if (share_name_ != &_default_share_name_) {
    share_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ShareToMe::share_name() const {
  return *share_name_;
}
inline void ShareToMe::set_share_name(const ::std::string& value) {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  share_name_->assign(value);
}
inline void ShareToMe::set_share_name(const char* value) {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  share_name_->assign(value);
}
inline void ShareToMe::set_share_name(const void* value, size_t size) {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  share_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareToMe::mutable_share_name() {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  return share_name_;
}

// required bytes owner = 3;
inline bool ShareToMe::has_owner() const {
  return _has_bit(2);
}
inline void ShareToMe::clear_owner() {
  if (owner_ != &_default_owner_) {
    owner_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ShareToMe::owner() const {
  return *owner_;
}
inline void ShareToMe::set_owner(const ::std::string& value) {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void ShareToMe::set_owner(const char* value) {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void ShareToMe::set_owner(const void* value, size_t size) {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareToMe::mutable_owner() {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  return owner_;
}

// repeated .maidsafe.MetaDataMap mdms = 4;
inline int ShareToMe::mdms_size() const {
  return mdms_.size();
}
inline void ShareToMe::clear_mdms() {
  mdms_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >&
ShareToMe::mdms() const {
  return mdms_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >*
ShareToMe::mutable_mdms() {
  return &mdms_;
}
inline const ::maidsafe::MetaDataMap& ShareToMe::mdms(int index) const {
  return mdms_.Get(index);
}
inline ::maidsafe::MetaDataMap* ShareToMe::mutable_mdms(int index) {
  return mdms_.Mutable(index);
}
inline ::maidsafe::MetaDataMap* ShareToMe::add_mdms() {
  return mdms_.Add();
}

// repeated .maidsafe.DataMap dms = 5;
inline int ShareToMe::dms_size() const {
  return dms_.size();
}
inline void ShareToMe::clear_dms() {
  dms_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >&
ShareToMe::dms() const {
  return dms_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >*
ShareToMe::mutable_dms() {
  return &dms_;
}
inline const ::maidsafe::DataMap& ShareToMe::dms(int index) const {
  return dms_.Get(index);
}
inline ::maidsafe::DataMap* ShareToMe::mutable_dms(int index) {
  return dms_.Mutable(index);
}
inline ::maidsafe::DataMap* ShareToMe::add_dms() {
  return dms_.Add();
}

// -------------------------------------------------------------------

// ShareToMeBufferMessage

// required int32 share_id = 1;
inline bool ShareToMeBufferMessage::has_share_id() const {
  return _has_bit(0);
}
inline void ShareToMeBufferMessage::clear_share_id() {
  share_id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ShareToMeBufferMessage::share_id() const {
  return share_id_;
}
inline void ShareToMeBufferMessage::set_share_id(::google::protobuf::int32 value) {
  _set_bit(0);
  share_id_ = value;
}

// optional bytes share_name = 2;
inline bool ShareToMeBufferMessage::has_share_name() const {
  return _has_bit(1);
}
inline void ShareToMeBufferMessage::clear_share_name() {
  if (share_name_ != &_default_share_name_) {
    share_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ShareToMeBufferMessage::share_name() const {
  return *share_name_;
}
inline void ShareToMeBufferMessage::set_share_name(const ::std::string& value) {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  share_name_->assign(value);
}
inline void ShareToMeBufferMessage::set_share_name(const char* value) {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  share_name_->assign(value);
}
inline void ShareToMeBufferMessage::set_share_name(const void* value, size_t size) {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  share_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareToMeBufferMessage::mutable_share_name() {
  _set_bit(1);
  if (share_name_ == &_default_share_name_) {
    share_name_ = new ::std::string;
  }
  return share_name_;
}

// required bytes owner = 3;
inline bool ShareToMeBufferMessage::has_owner() const {
  return _has_bit(2);
}
inline void ShareToMeBufferMessage::clear_owner() {
  if (owner_ != &_default_owner_) {
    owner_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ShareToMeBufferMessage::owner() const {
  return *owner_;
}
inline void ShareToMeBufferMessage::set_owner(const ::std::string& value) {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void ShareToMeBufferMessage::set_owner(const char* value) {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void ShareToMeBufferMessage::set_owner(const void* value, size_t size) {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareToMeBufferMessage::mutable_owner() {
  _set_bit(2);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  return owner_;
}

// required .maidsafe.ShareOperation op = 4;
inline bool ShareToMeBufferMessage::has_op() const {
  return _has_bit(3);
}
inline void ShareToMeBufferMessage::clear_op() {
  op_ = 0;
  _clear_bit(3);
}
inline maidsafe::ShareOperation ShareToMeBufferMessage::op() const {
  return static_cast< maidsafe::ShareOperation >(op_);
}
inline void ShareToMeBufferMessage::set_op(maidsafe::ShareOperation value) {
  GOOGLE_DCHECK(maidsafe::ShareOperation_IsValid(value));
  _set_bit(3);
  op_ = value;
}

// repeated .maidsafe.MetaDataMap mdms = 5;
inline int ShareToMeBufferMessage::mdms_size() const {
  return mdms_.size();
}
inline void ShareToMeBufferMessage::clear_mdms() {
  mdms_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >&
ShareToMeBufferMessage::mdms() const {
  return mdms_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >*
ShareToMeBufferMessage::mutable_mdms() {
  return &mdms_;
}
inline const ::maidsafe::MetaDataMap& ShareToMeBufferMessage::mdms(int index) const {
  return mdms_.Get(index);
}
inline ::maidsafe::MetaDataMap* ShareToMeBufferMessage::mutable_mdms(int index) {
  return mdms_.Mutable(index);
}
inline ::maidsafe::MetaDataMap* ShareToMeBufferMessage::add_mdms() {
  return mdms_.Add();
}

// repeated .maidsafe.DataMap dms = 6;
inline int ShareToMeBufferMessage::dms_size() const {
  return dms_.size();
}
inline void ShareToMeBufferMessage::clear_dms() {
  dms_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >&
ShareToMeBufferMessage::dms() const {
  return dms_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >*
ShareToMeBufferMessage::mutable_dms() {
  return &dms_;
}
inline const ::maidsafe::DataMap& ShareToMeBufferMessage::dms(int index) const {
  return dms_.Get(index);
}
inline ::maidsafe::DataMap* ShareToMeBufferMessage::mutable_dms(int index) {
  return dms_.Mutable(index);
}
inline ::maidsafe::DataMap* ShareToMeBufferMessage::add_dms() {
  return dms_.Add();
}

// -------------------------------------------------------------------

// DataAtlas

// optional bytes root_db_key = 1;
inline bool DataAtlas::has_root_db_key() const {
  return _has_bit(0);
}
inline void DataAtlas::clear_root_db_key() {
  if (root_db_key_ != &_default_root_db_key_) {
    root_db_key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DataAtlas::root_db_key() const {
  return *root_db_key_;
}
inline void DataAtlas::set_root_db_key(const ::std::string& value) {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  root_db_key_->assign(value);
}
inline void DataAtlas::set_root_db_key(const char* value) {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  root_db_key_->assign(value);
}
inline void DataAtlas::set_root_db_key(const void* value, size_t size) {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  root_db_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataAtlas::mutable_root_db_key() {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  return root_db_key_;
}

// repeated .maidsafe.Key keys = 2;
inline int DataAtlas::keys_size() const {
  return keys_.size();
}
inline void DataAtlas::clear_keys() {
  keys_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >&
DataAtlas::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >*
DataAtlas::mutable_keys() {
  return &keys_;
}
inline const ::maidsafe::Key& DataAtlas::keys(int index) const {
  return keys_.Get(index);
}
inline ::maidsafe::Key* DataAtlas::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline ::maidsafe::Key* DataAtlas::add_keys() {
  return keys_.Add();
}

// repeated .maidsafe.MetaDataMap mdms = 3;
inline int DataAtlas::mdms_size() const {
  return mdms_.size();
}
inline void DataAtlas::clear_mdms() {
  mdms_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >&
DataAtlas::mdms() const {
  return mdms_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >*
DataAtlas::mutable_mdms() {
  return &mdms_;
}
inline const ::maidsafe::MetaDataMap& DataAtlas::mdms(int index) const {
  return mdms_.Get(index);
}
inline ::maidsafe::MetaDataMap* DataAtlas::mutable_mdms(int index) {
  return mdms_.Mutable(index);
}
inline ::maidsafe::MetaDataMap* DataAtlas::add_mdms() {
  return mdms_.Add();
}

// repeated .maidsafe.DataMap dms = 4;
inline int DataAtlas::dms_size() const {
  return dms_.size();
}
inline void DataAtlas::clear_dms() {
  dms_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >&
DataAtlas::dms() const {
  return dms_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >*
DataAtlas::mutable_dms() {
  return &dms_;
}
inline const ::maidsafe::DataMap& DataAtlas::dms(int index) const {
  return dms_.Get(index);
}
inline ::maidsafe::DataMap* DataAtlas::mutable_dms(int index) {
  return dms_.Mutable(index);
}
inline ::maidsafe::DataMap* DataAtlas::add_dms() {
  return dms_.Add();
}

// repeated .maidsafe.ShareFromMe offered_share = 5;
inline int DataAtlas::offered_share_size() const {
  return offered_share_.size();
}
inline void DataAtlas::clear_offered_share() {
  offered_share_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareFromMe >&
DataAtlas::offered_share() const {
  return offered_share_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareFromMe >*
DataAtlas::mutable_offered_share() {
  return &offered_share_;
}
inline const ::maidsafe::ShareFromMe& DataAtlas::offered_share(int index) const {
  return offered_share_.Get(index);
}
inline ::maidsafe::ShareFromMe* DataAtlas::mutable_offered_share(int index) {
  return offered_share_.Mutable(index);
}
inline ::maidsafe::ShareFromMe* DataAtlas::add_offered_share() {
  return offered_share_.Add();
}

// repeated .maidsafe.ShareToMe accepted_share = 6;
inline int DataAtlas::accepted_share_size() const {
  return accepted_share_.size();
}
inline void DataAtlas::clear_accepted_share() {
  accepted_share_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareToMe >&
DataAtlas::accepted_share() const {
  return accepted_share_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareToMe >*
DataAtlas::mutable_accepted_share() {
  return &accepted_share_;
}
inline const ::maidsafe::ShareToMe& DataAtlas::accepted_share(int index) const {
  return accepted_share_.Get(index);
}
inline ::maidsafe::ShareToMe* DataAtlas::mutable_accepted_share(int index) {
  return accepted_share_.Mutable(index);
}
inline ::maidsafe::ShareToMe* DataAtlas::add_accepted_share() {
  return accepted_share_.Add();
}


}  // namespace maidsafe
#endif  // PROTOBUF_datamaps_2eproto__INCLUDED
