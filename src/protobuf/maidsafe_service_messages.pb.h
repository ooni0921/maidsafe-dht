// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_maidsafe_5fservice_5fmessages_2eproto__INCLUDED
#define PROTOBUF_maidsafe_5fservice_5fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace maidsafe {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto();
void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class StoreRequest;
class StoreResponse;
class DeleteRequest;
class DeleteResponse;
class GetRequest;
class GetResponse;
class CheckChunkRequest;
class CheckChunkResponse;
class ValidityCheckRequest;
class ValidityCheckResponse;
class UpdateRequest;
class UpdateResponse;
class GetMessagesRequest;
class GetMessagesResponse;
class SwapChunkRequest;
class SwapChunkResponse;

// ===================================================================

class StoreRequest : public ::google::protobuf::Message {
 public:
  StoreRequest();
  virtual ~StoreRequest();
  
  StoreRequest(const StoreRequest& from);
  
  inline StoreRequest& operator=(const StoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreRequest& default_instance();
  void Swap(StoreRequest* other);
  
  // implements Message ----------------------------------------------
  
  StoreRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // required bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 4;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 5;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
  // required int32 data_type = 6;
  inline bool has_data_type() const;
  inline void clear_data_type();
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  ::google::protobuf::int32 data_type_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreRequest* default_instance_;
};
// -------------------------------------------------------------------

class StoreResponse : public ::google::protobuf::Message {
 public:
  StoreResponse();
  virtual ~StoreResponse();
  
  StoreResponse(const StoreResponse& from);
  
  inline StoreResponse& operator=(const StoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreResponse& default_instance();
  void Swap(StoreResponse* other);
  
  // implements Message ----------------------------------------------
  
  StoreResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();
  
  DeleteRequest(const DeleteRequest& from);
  
  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();
  void Swap(DeleteRequest* other);
  
  // implements Message ----------------------------------------------
  
  DeleteRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 3;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 4;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
  // required int32 data_type = 5;
  inline bool has_data_type() const;
  inline void clear_data_type();
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  ::google::protobuf::int32 data_type_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteResponse : public ::google::protobuf::Message {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();
  
  DeleteResponse(const DeleteResponse& from);
  
  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteResponse& default_instance();
  void Swap(DeleteResponse* other);
  
  // implements Message ----------------------------------------------
  
  DeleteResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetRequest : public ::google::protobuf::Message {
 public:
  GetRequest();
  virtual ~GetRequest();
  
  GetRequest(const GetRequest& from);
  
  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRequest& default_instance();
  void Swap(GetRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetResponse : public ::google::protobuf::Message {
 public:
  GetResponse();
  virtual ~GetResponse();
  
  GetResponse(const GetResponse& from);
  
  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetResponse& default_instance();
  void Swap(GetResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes content = 2;
  inline bool has_content() const;
  inline void clear_content();
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  
  // optional bytes pmid_id = 3;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* content_;
  static const ::std::string _default_content_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetResponse* default_instance_;
};
// -------------------------------------------------------------------

class CheckChunkRequest : public ::google::protobuf::Message {
 public:
  CheckChunkRequest();
  virtual ~CheckChunkRequest();
  
  CheckChunkRequest(const CheckChunkRequest& from);
  
  inline CheckChunkRequest& operator=(const CheckChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckChunkRequest& default_instance();
  void Swap(CheckChunkRequest* other);
  
  // implements Message ----------------------------------------------
  
  CheckChunkRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CheckChunkRequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckChunkResponse : public ::google::protobuf::Message {
 public:
  CheckChunkResponse();
  virtual ~CheckChunkResponse();
  
  CheckChunkResponse(const CheckChunkResponse& from);
  
  inline CheckChunkResponse& operator=(const CheckChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckChunkResponse& default_instance();
  void Swap(CheckChunkResponse* other);
  
  // implements Message ----------------------------------------------
  
  CheckChunkResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // required bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CheckChunkResponse* default_instance_;
};
// -------------------------------------------------------------------

class ValidityCheckRequest : public ::google::protobuf::Message {
 public:
  ValidityCheckRequest();
  virtual ~ValidityCheckRequest();
  
  ValidityCheckRequest(const ValidityCheckRequest& from);
  
  inline ValidityCheckRequest& operator=(const ValidityCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidityCheckRequest& default_instance();
  void Swap(ValidityCheckRequest* other);
  
  // implements Message ----------------------------------------------
  
  ValidityCheckRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes random_data = 2;
  inline bool has_random_data() const;
  inline void clear_random_data();
  inline const ::std::string& random_data() const;
  inline void set_random_data(const ::std::string& value);
  inline void set_random_data(const char* value);
  inline void set_random_data(const void* value, size_t size);
  inline ::std::string* mutable_random_data();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* random_data_;
  static const ::std::string _default_random_data_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ValidityCheckRequest* default_instance_;
};
// -------------------------------------------------------------------

class ValidityCheckResponse : public ::google::protobuf::Message {
 public:
  ValidityCheckResponse();
  virtual ~ValidityCheckResponse();
  
  ValidityCheckResponse(const ValidityCheckResponse& from);
  
  inline ValidityCheckResponse& operator=(const ValidityCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidityCheckResponse& default_instance();
  void Swap(ValidityCheckResponse* other);
  
  // implements Message ----------------------------------------------
  
  ValidityCheckResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes hash_content = 2;
  inline bool has_hash_content() const;
  inline void clear_hash_content();
  inline const ::std::string& hash_content() const;
  inline void set_hash_content(const ::std::string& value);
  inline void set_hash_content(const char* value);
  inline void set_hash_content(const void* value, size_t size);
  inline ::std::string* mutable_hash_content();
  
  // required bytes pmid_id = 3;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* hash_content_;
  static const ::std::string _default_hash_content_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ValidityCheckResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateRequest : public ::google::protobuf::Message {
 public:
  UpdateRequest();
  virtual ~UpdateRequest();
  
  UpdateRequest(const UpdateRequest& from);
  
  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRequest& default_instance();
  void Swap(UpdateRequest* other);
  
  // implements Message ----------------------------------------------
  
  UpdateRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // required bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 4;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 5;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
  // required int32 data_type = 6;
  inline bool has_data_type() const;
  inline void clear_data_type();
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  ::google::protobuf::int32 data_type_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UpdateRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateResponse : public ::google::protobuf::Message {
 public:
  UpdateResponse();
  virtual ~UpdateResponse();
  
  UpdateResponse(const UpdateResponse& from);
  
  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateResponse& default_instance();
  void Swap(UpdateResponse* other);
  
  // implements Message ----------------------------------------------
  
  UpdateResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UpdateResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetMessagesRequest : public ::google::protobuf::Message {
 public:
  GetMessagesRequest();
  virtual ~GetMessagesRequest();
  
  GetMessagesRequest(const GetMessagesRequest& from);
  
  inline GetMessagesRequest& operator=(const GetMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMessagesRequest& default_instance();
  void Swap(GetMessagesRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetMessagesRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes buffer_packet_name = 1;
  inline bool has_buffer_packet_name() const;
  inline void clear_buffer_packet_name();
  inline const ::std::string& buffer_packet_name() const;
  inline void set_buffer_packet_name(const ::std::string& value);
  inline void set_buffer_packet_name(const char* value);
  inline void set_buffer_packet_name(const void* value, size_t size);
  inline ::std::string* mutable_buffer_packet_name();
  
  // required bytes public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 3;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* buffer_packet_name_;
  static const ::std::string _default_buffer_packet_name_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetMessagesRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetMessagesResponse : public ::google::protobuf::Message {
 public:
  GetMessagesResponse();
  virtual ~GetMessagesResponse();
  
  GetMessagesResponse(const GetMessagesResponse& from);
  
  inline GetMessagesResponse& operator=(const GetMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMessagesResponse& default_instance();
  void Swap(GetMessagesResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetMessagesResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // repeated bytes messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_messages();
  inline const ::std::string& messages(int index) const;
  inline ::std::string* mutable_messages(int index);
  inline void set_messages(int index, const ::std::string& value);
  inline void set_messages(int index, const char* value);
  inline ::std::string* add_messages();
  inline void add_messages(const ::std::string& value);
  inline void add_messages(const char* value);
  inline void set_messages(int index, const void* value, size_t size);
  inline void add_messages(const void* value, size_t size);
  
  // optional bytes pmid_id = 3;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::google::protobuf::RepeatedPtrField< ::std::string> messages_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetMessagesResponse* default_instance_;
};
// -------------------------------------------------------------------

class SwapChunkRequest : public ::google::protobuf::Message {
 public:
  SwapChunkRequest();
  virtual ~SwapChunkRequest();
  
  SwapChunkRequest(const SwapChunkRequest& from);
  
  inline SwapChunkRequest& operator=(const SwapChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapChunkRequest& default_instance();
  void Swap(SwapChunkRequest* other);
  
  // implements Message ----------------------------------------------
  
  SwapChunkRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 request_type = 1;
  inline bool has_request_type() const;
  inline void clear_request_type();
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);
  
  // required bytes chunkname1 = 2;
  inline bool has_chunkname1() const;
  inline void clear_chunkname1();
  inline const ::std::string& chunkname1() const;
  inline void set_chunkname1(const ::std::string& value);
  inline void set_chunkname1(const char* value);
  inline void set_chunkname1(const void* value, size_t size);
  inline ::std::string* mutable_chunkname1();
  
  // optional bytes chunkcontent1 = 3;
  inline bool has_chunkcontent1() const;
  inline void clear_chunkcontent1();
  inline const ::std::string& chunkcontent1() const;
  inline void set_chunkcontent1(const ::std::string& value);
  inline void set_chunkcontent1(const char* value);
  inline void set_chunkcontent1(const void* value, size_t size);
  inline ::std::string* mutable_chunkcontent1();
  
  // optional int32 size1 = 4;
  inline bool has_size1() const;
  inline void clear_size1();
  inline ::google::protobuf::int32 size1() const;
  inline void set_size1(::google::protobuf::int32 value);
  
  // optional bytes chunkname2 = 5;
  inline bool has_chunkname2() const;
  inline void clear_chunkname2();
  inline const ::std::string& chunkname2() const;
  inline void set_chunkname2(const ::std::string& value);
  inline void set_chunkname2(const char* value);
  inline void set_chunkname2(const void* value, size_t size);
  inline ::std::string* mutable_chunkname2();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 request_type_;
  ::std::string* chunkname1_;
  static const ::std::string _default_chunkname1_;
  ::std::string* chunkcontent1_;
  static const ::std::string _default_chunkcontent1_;
  ::google::protobuf::int32 size1_;
  ::std::string* chunkname2_;
  static const ::std::string _default_chunkname2_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SwapChunkRequest* default_instance_;
};
// -------------------------------------------------------------------

class SwapChunkResponse : public ::google::protobuf::Message {
 public:
  SwapChunkResponse();
  virtual ~SwapChunkResponse();
  
  SwapChunkResponse(const SwapChunkResponse& from);
  
  inline SwapChunkResponse& operator=(const SwapChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapChunkResponse& default_instance();
  void Swap(SwapChunkResponse* other);
  
  // implements Message ----------------------------------------------
  
  SwapChunkResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 request_type = 1;
  inline bool has_request_type() const;
  inline void clear_request_type();
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);
  
  // required bytes result = 2;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes chunkname1 = 3;
  inline bool has_chunkname1() const;
  inline void clear_chunkname1();
  inline const ::std::string& chunkname1() const;
  inline void set_chunkname1(const ::std::string& value);
  inline void set_chunkname1(const char* value);
  inline void set_chunkname1(const void* value, size_t size);
  inline ::std::string* mutable_chunkname1();
  
  // optional bytes chunkcontent1 = 4;
  inline bool has_chunkcontent1() const;
  inline void clear_chunkcontent1();
  inline const ::std::string& chunkcontent1() const;
  inline void set_chunkcontent1(const ::std::string& value);
  inline void set_chunkcontent1(const char* value);
  inline void set_chunkcontent1(const void* value, size_t size);
  inline ::std::string* mutable_chunkcontent1();
  
  // optional int32 size1 = 5;
  inline bool has_size1() const;
  inline void clear_size1();
  inline ::google::protobuf::int32 size1() const;
  inline void set_size1(::google::protobuf::int32 value);
  
  // optional bytes chunkname2 = 6;
  inline bool has_chunkname2() const;
  inline void clear_chunkname2();
  inline const ::std::string& chunkname2() const;
  inline void set_chunkname2(const ::std::string& value);
  inline void set_chunkname2(const char* value);
  inline void set_chunkname2(const void* value, size_t size);
  inline ::std::string* mutable_chunkname2();
  
  // optional bytes chunkcontent2 = 7;
  inline bool has_chunkcontent2() const;
  inline void clear_chunkcontent2();
  inline const ::std::string& chunkcontent2() const;
  inline void set_chunkcontent2(const ::std::string& value);
  inline void set_chunkcontent2(const char* value);
  inline void set_chunkcontent2(const void* value, size_t size);
  inline ::std::string* mutable_chunkcontent2();
  
  // optional int32 size2 = 8;
  inline bool has_size2() const;
  inline void clear_size2();
  inline ::google::protobuf::int32 size2() const;
  inline void set_size2(::google::protobuf::int32 value);
  
  // required bytes pmid_id = 9;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 request_type_;
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* chunkname1_;
  static const ::std::string _default_chunkname1_;
  ::std::string* chunkcontent1_;
  static const ::std::string _default_chunkcontent1_;
  ::google::protobuf::int32 size1_;
  ::std::string* chunkname2_;
  static const ::std::string _default_chunkname2_;
  ::std::string* chunkcontent2_;
  static const ::std::string _default_chunkcontent2_;
  ::google::protobuf::int32 size2_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void protobuf_BuildDesc_maidsafe_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SwapChunkResponse* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// StoreRequest

// required bytes chunkname = 1;
inline bool StoreRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void StoreRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StoreRequest::chunkname() const {
  return *chunkname_;
}
inline void StoreRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StoreRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StoreRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes data = 2;
inline bool StoreRequest::has_data() const {
  return _has_bit(1);
}
inline void StoreRequest::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreRequest::data() const {
  return *data_;
}
inline void StoreRequest::set_data(const ::std::string& value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StoreRequest::set_data(const char* value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StoreRequest::set_data(const void* value, size_t size) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_data() {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// required bytes public_key = 3;
inline bool StoreRequest::has_public_key() const {
  return _has_bit(2);
}
inline void StoreRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StoreRequest::public_key() const {
  return *public_key_;
}
inline void StoreRequest::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreRequest::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreRequest::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 4;
inline bool StoreRequest::has_signed_public_key() const {
  return _has_bit(3);
}
inline void StoreRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StoreRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void StoreRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreRequest::set_signed_public_key(const char* value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_signed_public_key() {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 5;
inline bool StoreRequest::has_signed_request() const {
  return _has_bit(4);
}
inline void StoreRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StoreRequest::signed_request() const {
  return *signed_request_;
}
inline void StoreRequest::set_signed_request(const ::std::string& value) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StoreRequest::set_signed_request(const char* value) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StoreRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_signed_request() {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// required int32 data_type = 6;
inline bool StoreRequest::has_data_type() const {
  return _has_bit(5);
}
inline void StoreRequest::clear_data_type() {
  data_type_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 StoreRequest::data_type() const {
  return data_type_;
}
inline void StoreRequest::set_data_type(::google::protobuf::int32 value) {
  _set_bit(5);
  data_type_ = value;
}

// -------------------------------------------------------------------

// StoreResponse

// required bytes result = 1;
inline bool StoreResponse::has_result() const {
  return _has_bit(0);
}
inline void StoreResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StoreResponse::result() const {
  return *result_;
}
inline void StoreResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void StoreResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void StoreResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes pmid_id = 2;
inline bool StoreResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void StoreResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreResponse::pmid_id() const {
  return *pmid_id_;
}
inline void StoreResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void StoreResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void StoreResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// DeleteRequest

// required bytes chunkname = 1;
inline bool DeleteRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void DeleteRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DeleteRequest::chunkname() const {
  return *chunkname_;
}
inline void DeleteRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void DeleteRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void DeleteRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes public_key = 2;
inline bool DeleteRequest::has_public_key() const {
  return _has_bit(1);
}
inline void DeleteRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DeleteRequest::public_key() const {
  return *public_key_;
}
inline void DeleteRequest::set_public_key(const ::std::string& value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void DeleteRequest::set_public_key(const char* value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void DeleteRequest::set_public_key(const void* value, size_t size) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteRequest::mutable_public_key() {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 3;
inline bool DeleteRequest::has_signed_public_key() const {
  return _has_bit(2);
}
inline void DeleteRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& DeleteRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void DeleteRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void DeleteRequest::set_signed_public_key(const char* value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void DeleteRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteRequest::mutable_signed_public_key() {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 4;
inline bool DeleteRequest::has_signed_request() const {
  return _has_bit(3);
}
inline void DeleteRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& DeleteRequest::signed_request() const {
  return *signed_request_;
}
inline void DeleteRequest::set_signed_request(const ::std::string& value) {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void DeleteRequest::set_signed_request(const char* value) {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void DeleteRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteRequest::mutable_signed_request() {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// required int32 data_type = 5;
inline bool DeleteRequest::has_data_type() const {
  return _has_bit(4);
}
inline void DeleteRequest::clear_data_type() {
  data_type_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 DeleteRequest::data_type() const {
  return data_type_;
}
inline void DeleteRequest::set_data_type(::google::protobuf::int32 value) {
  _set_bit(4);
  data_type_ = value;
}

// -------------------------------------------------------------------

// DeleteResponse

// required bytes result = 1;
inline bool DeleteResponse::has_result() const {
  return _has_bit(0);
}
inline void DeleteResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DeleteResponse::result() const {
  return *result_;
}
inline void DeleteResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void DeleteResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void DeleteResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes pmid_id = 2;
inline bool DeleteResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void DeleteResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DeleteResponse::pmid_id() const {
  return *pmid_id_;
}
inline void DeleteResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void DeleteResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void DeleteResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// GetRequest

// required bytes chunkname = 1;
inline bool GetRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void GetRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GetRequest::chunkname() const {
  return *chunkname_;
}
inline void GetRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void GetRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void GetRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// -------------------------------------------------------------------

// GetResponse

// required bytes result = 1;
inline bool GetResponse::has_result() const {
  return _has_bit(0);
}
inline void GetResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GetResponse::result() const {
  return *result_;
}
inline void GetResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void GetResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void GetResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes content = 2;
inline bool GetResponse::has_content() const {
  return _has_bit(1);
}
inline void GetResponse::clear_content() {
  if (content_ != &_default_content_) {
    content_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GetResponse::content() const {
  return *content_;
}
inline void GetResponse::set_content(const ::std::string& value) {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void GetResponse::set_content(const char* value) {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void GetResponse::set_content(const void* value, size_t size) {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetResponse::mutable_content() {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  return content_;
}

// optional bytes pmid_id = 3;
inline bool GetResponse::has_pmid_id() const {
  return _has_bit(2);
}
inline void GetResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetResponse::pmid_id() const {
  return *pmid_id_;
}
inline void GetResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void GetResponse::set_pmid_id(const char* value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void GetResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetResponse::mutable_pmid_id() {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// CheckChunkRequest

// required bytes chunkname = 1;
inline bool CheckChunkRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void CheckChunkRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CheckChunkRequest::chunkname() const {
  return *chunkname_;
}
inline void CheckChunkRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void CheckChunkRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void CheckChunkRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckChunkRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// -------------------------------------------------------------------

// CheckChunkResponse

// required bytes result = 1;
inline bool CheckChunkResponse::has_result() const {
  return _has_bit(0);
}
inline void CheckChunkResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CheckChunkResponse::result() const {
  return *result_;
}
inline void CheckChunkResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void CheckChunkResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void CheckChunkResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckChunkResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// required bytes pmid_id = 2;
inline bool CheckChunkResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void CheckChunkResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CheckChunkResponse::pmid_id() const {
  return *pmid_id_;
}
inline void CheckChunkResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void CheckChunkResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void CheckChunkResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckChunkResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// ValidityCheckRequest

// required bytes chunkname = 1;
inline bool ValidityCheckRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void ValidityCheckRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ValidityCheckRequest::chunkname() const {
  return *chunkname_;
}
inline void ValidityCheckRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void ValidityCheckRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void ValidityCheckRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes random_data = 2;
inline bool ValidityCheckRequest::has_random_data() const {
  return _has_bit(1);
}
inline void ValidityCheckRequest::clear_random_data() {
  if (random_data_ != &_default_random_data_) {
    random_data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ValidityCheckRequest::random_data() const {
  return *random_data_;
}
inline void ValidityCheckRequest::set_random_data(const ::std::string& value) {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  random_data_->assign(value);
}
inline void ValidityCheckRequest::set_random_data(const char* value) {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  random_data_->assign(value);
}
inline void ValidityCheckRequest::set_random_data(const void* value, size_t size) {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  random_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckRequest::mutable_random_data() {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  return random_data_;
}

// -------------------------------------------------------------------

// ValidityCheckResponse

// required bytes result = 1;
inline bool ValidityCheckResponse::has_result() const {
  return _has_bit(0);
}
inline void ValidityCheckResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ValidityCheckResponse::result() const {
  return *result_;
}
inline void ValidityCheckResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void ValidityCheckResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void ValidityCheckResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes hash_content = 2;
inline bool ValidityCheckResponse::has_hash_content() const {
  return _has_bit(1);
}
inline void ValidityCheckResponse::clear_hash_content() {
  if (hash_content_ != &_default_hash_content_) {
    hash_content_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ValidityCheckResponse::hash_content() const {
  return *hash_content_;
}
inline void ValidityCheckResponse::set_hash_content(const ::std::string& value) {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  hash_content_->assign(value);
}
inline void ValidityCheckResponse::set_hash_content(const char* value) {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  hash_content_->assign(value);
}
inline void ValidityCheckResponse::set_hash_content(const void* value, size_t size) {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  hash_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckResponse::mutable_hash_content() {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  return hash_content_;
}

// required bytes pmid_id = 3;
inline bool ValidityCheckResponse::has_pmid_id() const {
  return _has_bit(2);
}
inline void ValidityCheckResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ValidityCheckResponse::pmid_id() const {
  return *pmid_id_;
}
inline void ValidityCheckResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void ValidityCheckResponse::set_pmid_id(const char* value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void ValidityCheckResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckResponse::mutable_pmid_id() {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// UpdateRequest

// required bytes chunkname = 1;
inline bool UpdateRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void UpdateRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& UpdateRequest::chunkname() const {
  return *chunkname_;
}
inline void UpdateRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void UpdateRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void UpdateRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes data = 2;
inline bool UpdateRequest::has_data() const {
  return _has_bit(1);
}
inline void UpdateRequest::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& UpdateRequest::data() const {
  return *data_;
}
inline void UpdateRequest::set_data(const ::std::string& value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UpdateRequest::set_data(const char* value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UpdateRequest::set_data(const void* value, size_t size) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateRequest::mutable_data() {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// required bytes public_key = 3;
inline bool UpdateRequest::has_public_key() const {
  return _has_bit(2);
}
inline void UpdateRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& UpdateRequest::public_key() const {
  return *public_key_;
}
inline void UpdateRequest::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void UpdateRequest::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void UpdateRequest::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateRequest::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 4;
inline bool UpdateRequest::has_signed_public_key() const {
  return _has_bit(3);
}
inline void UpdateRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& UpdateRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void UpdateRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void UpdateRequest::set_signed_public_key(const char* value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void UpdateRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateRequest::mutable_signed_public_key() {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 5;
inline bool UpdateRequest::has_signed_request() const {
  return _has_bit(4);
}
inline void UpdateRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& UpdateRequest::signed_request() const {
  return *signed_request_;
}
inline void UpdateRequest::set_signed_request(const ::std::string& value) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void UpdateRequest::set_signed_request(const char* value) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void UpdateRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateRequest::mutable_signed_request() {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// required int32 data_type = 6;
inline bool UpdateRequest::has_data_type() const {
  return _has_bit(5);
}
inline void UpdateRequest::clear_data_type() {
  data_type_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 UpdateRequest::data_type() const {
  return data_type_;
}
inline void UpdateRequest::set_data_type(::google::protobuf::int32 value) {
  _set_bit(5);
  data_type_ = value;
}

// -------------------------------------------------------------------

// UpdateResponse

// required bytes result = 1;
inline bool UpdateResponse::has_result() const {
  return _has_bit(0);
}
inline void UpdateResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& UpdateResponse::result() const {
  return *result_;
}
inline void UpdateResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void UpdateResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void UpdateResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes pmid_id = 2;
inline bool UpdateResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void UpdateResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& UpdateResponse::pmid_id() const {
  return *pmid_id_;
}
inline void UpdateResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void UpdateResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void UpdateResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// GetMessagesRequest

// required bytes buffer_packet_name = 1;
inline bool GetMessagesRequest::has_buffer_packet_name() const {
  return _has_bit(0);
}
inline void GetMessagesRequest::clear_buffer_packet_name() {
  if (buffer_packet_name_ != &_default_buffer_packet_name_) {
    buffer_packet_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GetMessagesRequest::buffer_packet_name() const {
  return *buffer_packet_name_;
}
inline void GetMessagesRequest::set_buffer_packet_name(const ::std::string& value) {
  _set_bit(0);
  if (buffer_packet_name_ == &_default_buffer_packet_name_) {
    buffer_packet_name_ = new ::std::string;
  }
  buffer_packet_name_->assign(value);
}
inline void GetMessagesRequest::set_buffer_packet_name(const char* value) {
  _set_bit(0);
  if (buffer_packet_name_ == &_default_buffer_packet_name_) {
    buffer_packet_name_ = new ::std::string;
  }
  buffer_packet_name_->assign(value);
}
inline void GetMessagesRequest::set_buffer_packet_name(const void* value, size_t size) {
  _set_bit(0);
  if (buffer_packet_name_ == &_default_buffer_packet_name_) {
    buffer_packet_name_ = new ::std::string;
  }
  buffer_packet_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMessagesRequest::mutable_buffer_packet_name() {
  _set_bit(0);
  if (buffer_packet_name_ == &_default_buffer_packet_name_) {
    buffer_packet_name_ = new ::std::string;
  }
  return buffer_packet_name_;
}

// required bytes public_key = 2;
inline bool GetMessagesRequest::has_public_key() const {
  return _has_bit(1);
}
inline void GetMessagesRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GetMessagesRequest::public_key() const {
  return *public_key_;
}
inline void GetMessagesRequest::set_public_key(const ::std::string& value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void GetMessagesRequest::set_public_key(const char* value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void GetMessagesRequest::set_public_key(const void* value, size_t size) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMessagesRequest::mutable_public_key() {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 3;
inline bool GetMessagesRequest::has_signed_public_key() const {
  return _has_bit(2);
}
inline void GetMessagesRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetMessagesRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void GetMessagesRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void GetMessagesRequest::set_signed_public_key(const char* value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void GetMessagesRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMessagesRequest::mutable_signed_public_key() {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// -------------------------------------------------------------------

// GetMessagesResponse

// required bytes result = 1;
inline bool GetMessagesResponse::has_result() const {
  return _has_bit(0);
}
inline void GetMessagesResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GetMessagesResponse::result() const {
  return *result_;
}
inline void GetMessagesResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void GetMessagesResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void GetMessagesResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMessagesResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// repeated bytes messages = 2;
inline int GetMessagesResponse::messages_size() const {
  return messages_.size();
}
inline void GetMessagesResponse::clear_messages() {
  messages_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetMessagesResponse::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetMessagesResponse::mutable_messages() {
  return &messages_;
}
inline const ::std::string& GetMessagesResponse::messages(int index) const {
  return messages_.Get(index);
}
inline ::std::string* GetMessagesResponse::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline void GetMessagesResponse::set_messages(int index, const ::std::string& value) {
  messages_.Mutable(index)->assign(value);
}
inline void GetMessagesResponse::set_messages(int index, const char* value) {
  messages_.Mutable(index)->assign(value);
}
inline ::std::string* GetMessagesResponse::add_messages() {
  return messages_.Add();
}
inline void GetMessagesResponse::add_messages(const ::std::string& value) {
  messages_.Add()->assign(value);
}
inline void GetMessagesResponse::add_messages(const char* value) {
  messages_.Add()->assign(value);
}
inline void GetMessagesResponse::set_messages(int index, const void* value, size_t size) {
  messages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void GetMessagesResponse::add_messages(const void* value, size_t size) {
  messages_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// optional bytes pmid_id = 3;
inline bool GetMessagesResponse::has_pmid_id() const {
  return _has_bit(2);
}
inline void GetMessagesResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetMessagesResponse::pmid_id() const {
  return *pmid_id_;
}
inline void GetMessagesResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void GetMessagesResponse::set_pmid_id(const char* value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void GetMessagesResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMessagesResponse::mutable_pmid_id() {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// SwapChunkRequest

// required int32 request_type = 1;
inline bool SwapChunkRequest::has_request_type() const {
  return _has_bit(0);
}
inline void SwapChunkRequest::clear_request_type() {
  request_type_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 SwapChunkRequest::request_type() const {
  return request_type_;
}
inline void SwapChunkRequest::set_request_type(::google::protobuf::int32 value) {
  _set_bit(0);
  request_type_ = value;
}

// required bytes chunkname1 = 2;
inline bool SwapChunkRequest::has_chunkname1() const {
  return _has_bit(1);
}
inline void SwapChunkRequest::clear_chunkname1() {
  if (chunkname1_ != &_default_chunkname1_) {
    chunkname1_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SwapChunkRequest::chunkname1() const {
  return *chunkname1_;
}
inline void SwapChunkRequest::set_chunkname1(const ::std::string& value) {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkRequest::set_chunkname1(const char* value) {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkRequest::set_chunkname1(const void* value, size_t size) {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkRequest::mutable_chunkname1() {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  return chunkname1_;
}

// optional bytes chunkcontent1 = 3;
inline bool SwapChunkRequest::has_chunkcontent1() const {
  return _has_bit(2);
}
inline void SwapChunkRequest::clear_chunkcontent1() {
  if (chunkcontent1_ != &_default_chunkcontent1_) {
    chunkcontent1_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& SwapChunkRequest::chunkcontent1() const {
  return *chunkcontent1_;
}
inline void SwapChunkRequest::set_chunkcontent1(const ::std::string& value) {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkRequest::set_chunkcontent1(const char* value) {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkRequest::set_chunkcontent1(const void* value, size_t size) {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkRequest::mutable_chunkcontent1() {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  return chunkcontent1_;
}

// optional int32 size1 = 4;
inline bool SwapChunkRequest::has_size1() const {
  return _has_bit(3);
}
inline void SwapChunkRequest::clear_size1() {
  size1_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 SwapChunkRequest::size1() const {
  return size1_;
}
inline void SwapChunkRequest::set_size1(::google::protobuf::int32 value) {
  _set_bit(3);
  size1_ = value;
}

// optional bytes chunkname2 = 5;
inline bool SwapChunkRequest::has_chunkname2() const {
  return _has_bit(4);
}
inline void SwapChunkRequest::clear_chunkname2() {
  if (chunkname2_ != &_default_chunkname2_) {
    chunkname2_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& SwapChunkRequest::chunkname2() const {
  return *chunkname2_;
}
inline void SwapChunkRequest::set_chunkname2(const ::std::string& value) {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkRequest::set_chunkname2(const char* value) {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkRequest::set_chunkname2(const void* value, size_t size) {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkRequest::mutable_chunkname2() {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  return chunkname2_;
}

// -------------------------------------------------------------------

// SwapChunkResponse

// required int32 request_type = 1;
inline bool SwapChunkResponse::has_request_type() const {
  return _has_bit(0);
}
inline void SwapChunkResponse::clear_request_type() {
  request_type_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 SwapChunkResponse::request_type() const {
  return request_type_;
}
inline void SwapChunkResponse::set_request_type(::google::protobuf::int32 value) {
  _set_bit(0);
  request_type_ = value;
}

// required bytes result = 2;
inline bool SwapChunkResponse::has_result() const {
  return _has_bit(1);
}
inline void SwapChunkResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SwapChunkResponse::result() const {
  return *result_;
}
inline void SwapChunkResponse::set_result(const ::std::string& value) {
  _set_bit(1);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void SwapChunkResponse::set_result(const char* value) {
  _set_bit(1);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void SwapChunkResponse::set_result(const void* value, size_t size) {
  _set_bit(1);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_result() {
  _set_bit(1);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes chunkname1 = 3;
inline bool SwapChunkResponse::has_chunkname1() const {
  return _has_bit(2);
}
inline void SwapChunkResponse::clear_chunkname1() {
  if (chunkname1_ != &_default_chunkname1_) {
    chunkname1_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& SwapChunkResponse::chunkname1() const {
  return *chunkname1_;
}
inline void SwapChunkResponse::set_chunkname1(const ::std::string& value) {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkResponse::set_chunkname1(const char* value) {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkResponse::set_chunkname1(const void* value, size_t size) {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkname1() {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  return chunkname1_;
}

// optional bytes chunkcontent1 = 4;
inline bool SwapChunkResponse::has_chunkcontent1() const {
  return _has_bit(3);
}
inline void SwapChunkResponse::clear_chunkcontent1() {
  if (chunkcontent1_ != &_default_chunkcontent1_) {
    chunkcontent1_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& SwapChunkResponse::chunkcontent1() const {
  return *chunkcontent1_;
}
inline void SwapChunkResponse::set_chunkcontent1(const ::std::string& value) {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent1(const char* value) {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent1(const void* value, size_t size) {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkcontent1() {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  return chunkcontent1_;
}

// optional int32 size1 = 5;
inline bool SwapChunkResponse::has_size1() const {
  return _has_bit(4);
}
inline void SwapChunkResponse::clear_size1() {
  size1_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 SwapChunkResponse::size1() const {
  return size1_;
}
inline void SwapChunkResponse::set_size1(::google::protobuf::int32 value) {
  _set_bit(4);
  size1_ = value;
}

// optional bytes chunkname2 = 6;
inline bool SwapChunkResponse::has_chunkname2() const {
  return _has_bit(5);
}
inline void SwapChunkResponse::clear_chunkname2() {
  if (chunkname2_ != &_default_chunkname2_) {
    chunkname2_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& SwapChunkResponse::chunkname2() const {
  return *chunkname2_;
}
inline void SwapChunkResponse::set_chunkname2(const ::std::string& value) {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkResponse::set_chunkname2(const char* value) {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkResponse::set_chunkname2(const void* value, size_t size) {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkname2() {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  return chunkname2_;
}

// optional bytes chunkcontent2 = 7;
inline bool SwapChunkResponse::has_chunkcontent2() const {
  return _has_bit(6);
}
inline void SwapChunkResponse::clear_chunkcontent2() {
  if (chunkcontent2_ != &_default_chunkcontent2_) {
    chunkcontent2_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& SwapChunkResponse::chunkcontent2() const {
  return *chunkcontent2_;
}
inline void SwapChunkResponse::set_chunkcontent2(const ::std::string& value) {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  chunkcontent2_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent2(const char* value) {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  chunkcontent2_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent2(const void* value, size_t size) {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  chunkcontent2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkcontent2() {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  return chunkcontent2_;
}

// optional int32 size2 = 8;
inline bool SwapChunkResponse::has_size2() const {
  return _has_bit(7);
}
inline void SwapChunkResponse::clear_size2() {
  size2_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 SwapChunkResponse::size2() const {
  return size2_;
}
inline void SwapChunkResponse::set_size2(::google::protobuf::int32 value) {
  _set_bit(7);
  size2_ = value;
}

// required bytes pmid_id = 9;
inline bool SwapChunkResponse::has_pmid_id() const {
  return _has_bit(8);
}
inline void SwapChunkResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& SwapChunkResponse::pmid_id() const {
  return *pmid_id_;
}
inline void SwapChunkResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(8);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void SwapChunkResponse::set_pmid_id(const char* value) {
  _set_bit(8);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void SwapChunkResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(8);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_pmid_id() {
  _set_bit(8);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}


}  // namespace maidsafe
#endif  // PROTOBUF_maidsafe_5fservice_5fmessages_2eproto__INCLUDED
