/*
 * copyright maidsafe.net limited 2008
 * The following source code is property of maidsafe.net limited and
 * is not meant for external use. The use of this code is governed
 * by the license file LICENSE.TXT found in teh root of this directory and also
 * on www.maidsafe.net.
 *
 * You are not free to copy, amend or otherwise use this source code without
 * explicit written permission of the board of directors of maidsafe.net
 *
 *  Created on: Nov 16, 2008
 *      Author: dan
 */

#include "base/configfile.h"

namespace base {

int ConfigFileHandler::readFile() {
  try {
    config_.readFile(fileName_.c_str());
    return 0;
  }
  catch(const libconfig::FileIOException &fioe) {
    std::cout << "File not found!" << std::endl;
    return -1;
  }
  catch(libconfig::ParseException pe) {
    std::cout << "Parsing file exception: Check your grammar!" << std::endl;
    std::cout << "Line " << pe.getLine() << ": " << pe.getError() << std::endl;
    return -2;
  }
}

int ConfigFileHandler::writeFile() {
  try {
    config_.writeFile(fileName_.c_str());
    return 0;
  }
  catch(const libconfig::FileIOException &fioe) {
    std::cout << "File not found!" << std::endl;
    return -1;
  }
}

int ConfigFileHandler::getAttributeList(const std::string &attributeName,
  std::vector<std::string> &list) {
  //  Read, parse and verify attribute
  result_ = readFile();
  if (result_ != 0)
    return result_;
  if (!config_.exists(attributeName.c_str()))
    return -3;
  libconfig::Setting& setting = config_.lookup(attributeName.c_str());
  if (!setting.isList())
    return -4;
  if (setting.getLength() == 0)
    return -5;

  //  Fill vector list with values
  for (int n = 0; n < setting.getLength(); n++) {
    std::cout << (const char*)setting[n] << std::endl;
    std::string s((const char*)setting[n]);
    list.push_back(s);
  }

  return 0;
}

int ConfigFileHandler::addListAttribute(const std::string &attributeName,
  const std::string &attributeValue) {
  std::vector<std::string> list;
  result_ = getAttributeList(attributeName, list);
  if (result_ != 0)
    return result_;

  //  Read, parse and verify attribute
  result_ = readFile();
  if (result_ != 0)
    return result_;
  if (!config_.exists(attributeName.c_str()))
    return -3;
  libconfig::Setting& setting = config_.lookup(attributeName.c_str());
  if (!setting.isList())
    return -4;

  //  Check to see if value is already in list
  for (unsigned int n = 0; n < list.size(); n++) {
    std::string s = list[n];
    if (s.compare(attributeValue) == 0)
      return -6;
  }

  //  Add new value to list
  int size = setting.getLength();
  setting.add(libconfig::Setting::TypeString);
  setting[size] = attributeValue.c_str();

  //  Re-write the config file
  result_ = writeFile();
  if (result_ != 0)
    return result_;

  return 0;
}

int ConfigFileHandler::addAttribute(const std::string &attributeParent,
  const std::string &attributeName, const std::string &attributeValue) {
  // Build the full path to the new element
  std::string full_path = attributeParent + "." + attributeName;

  //  Read, parse and verify attribute
  result_ = readFile();
  if (result_ != 0)
    return result_;
  if (config_.exists(full_path.c_str()))
    return -8;
  if (!config_.exists(attributeParent.c_str()))
    return -9;
  libconfig::Setting& setting = config_.lookup(attributeParent.c_str());

  //  Add attribute
  setting.add(attributeName.c_str(), libconfig::Setting::TypeString);

  //  Re-write the config file
  result_ = writeFile();
  if (result_ != 0)
    return result_;

  //  Re-read, parse and verify attribute
  result_ = readFile();
  if (result_ != 0)
    return result_;

  //  Modify value
  libconfig::Setting& setting1 = config_.lookup(full_path.c_str());
  setting1 = attributeValue.c_str();

  //  Re-write the config file
  result_ = writeFile();
  if (result_ != 0)
    return result_;

  return 0;
}

int ConfigFileHandler::getAttribute(const std::string &attributeName,
  std::string &attributeValue) {
  //  Read, parse and verify attribute
  result_ = readFile();
  if (result_ != 0)
    return result_;
  if (!config_.exists(attributeName.c_str()))
    return -3;
  libconfig::Setting& setting = config_.lookup(attributeName.c_str());
  if (setting.getType() != libconfig::Setting::TypeString)
    return -7;

  //  Assign the value to the given variable
  attributeValue = (const char*)setting;

  return 0;
}

int ConfigFileHandler::modifyAttribute(const std::string &attributeName,
  const std::string &attributeValue) {
  //  Re-read, parse and verify attribute
  result_ = readFile();
  if (result_ != 0)
    return result_;
  if (!config_.exists(attributeName.c_str()))
    return -3;
  libconfig::Setting& setting = config_.lookup(attributeName.c_str());
  if (setting.getType() != libconfig::Setting::TypeString)
    return -7;

  //  Modify value
  libconfig::Setting& setting1 = config_.lookup(attributeName);
  setting1 = attributeValue.c_str();

  //  Re-write the config file
  result_ = writeFile();
  if (result_ != 0)
    return result_;

  return 0;
}

int ConfigFileHandler::removeAttribute(const std::string &attributeParent,
  const std::string &attributeName) {
  // Build the full path to the new element
  std::string full_path = attributeParent + "." + attributeName;

  //  Re-read, parse and verify attribute
  result_ = readFile();
  if (result_ != 0)
    return result_;
  if (!config_.exists(full_path.c_str()))
    return -3;

  //  Look up and remove
  libconfig::Setting& setting = config_.lookup(attributeParent.c_str());
  setting.remove(attributeName.c_str());

  //  Re-write the config file
  result_ = writeFile();
  if (result_ != 0)
    return result_;

  return 0;
}

}  // namespace
