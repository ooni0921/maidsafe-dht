// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_packet_2eproto__INCLUDED
#define PROTOBUF_packet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace packethandler {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_packet_2eproto();
void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class GenericPacket;
class BufferPacketInfo;
class BufferPacketMessage;
class BufferPacket;
class ValidatedBufferPacketMessage;
class ContactInfo;
class InstantMessage;
class InstantFileMessage;
class StoreMessagesResult;
class CreateMSIDResult;
class PrivateShareNotification;

enum MessageType {
  SHARE = 0,
  ADD_CONTACT_RQST = 1,
  GENERAL = 2,
  ADD_CONTACT_RESPONSE = 3,
  INSTANT_MSG = 4,
  INSTANT_FILE = 5,
  DELETE_CONTACT_NOTIF = 6
};
const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = SHARE;
const MessageType MessageType_MAX = DELETE_CONTACT_NOTIF;

// ===================================================================

class GenericPacket : public ::google::protobuf::Message {
 public:
  GenericPacket();
  virtual ~GenericPacket();
  
  GenericPacket(const GenericPacket& from);
  
  inline GenericPacket& operator=(const GenericPacket& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericPacket& default_instance();
  void Swap(GenericPacket* other);
  
  // implements Message ----------------------------------------------
  
  GenericPacket* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string data = 1;
  inline bool has_data() const;
  inline void clear_data();
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline ::std::string* mutable_data();
  
  // required string signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline ::std::string* mutable_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* signature_;
  static const ::std::string _default_signature_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GenericPacket* default_instance_;
};
// -------------------------------------------------------------------

class BufferPacketInfo : public ::google::protobuf::Message {
 public:
  BufferPacketInfo();
  virtual ~BufferPacketInfo();
  
  BufferPacketInfo(const BufferPacketInfo& from);
  
  inline BufferPacketInfo& operator=(const BufferPacketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferPacketInfo& default_instance();
  void Swap(BufferPacketInfo* other);
  
  // implements Message ----------------------------------------------
  
  BufferPacketInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string owner = 1;
  inline bool has_owner() const;
  inline void clear_owner();
  inline const ::std::string& owner() const;
  inline void set_owner(const ::std::string& value);
  inline void set_owner(const char* value);
  inline ::std::string* mutable_owner();
  
  // required string ownerPublicKey = 2;
  inline bool has_ownerpublickey() const;
  inline void clear_ownerpublickey();
  inline const ::std::string& ownerpublickey() const;
  inline void set_ownerpublickey(const ::std::string& value);
  inline void set_ownerpublickey(const char* value);
  inline ::std::string* mutable_ownerpublickey();
  
  // repeated string users = 3;
  inline int users_size() const;
  inline void clear_users();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& users() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_users();
  inline const ::std::string& users(int index) const;
  inline ::std::string* mutable_users(int index);
  inline void set_users(int index, const ::std::string& value);
  inline void set_users(int index, const char* value);
  inline ::std::string* add_users();
  inline void add_users(const ::std::string& value);
  inline void add_users(const char* value);
  
  // optional bool online = 4;
  inline bool has_online() const;
  inline void clear_online();
  inline bool online() const;
  inline void set_online(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* owner_;
  static const ::std::string _default_owner_;
  ::std::string* ownerpublickey_;
  static const ::std::string _default_ownerpublickey_;
  ::google::protobuf::RepeatedPtrField< ::std::string> users_;
  bool online_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BufferPacketInfo* default_instance_;
};
// -------------------------------------------------------------------

class BufferPacketMessage : public ::google::protobuf::Message {
 public:
  BufferPacketMessage();
  virtual ~BufferPacketMessage();
  
  BufferPacketMessage(const BufferPacketMessage& from);
  
  inline BufferPacketMessage& operator=(const BufferPacketMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferPacketMessage& default_instance();
  void Swap(BufferPacketMessage* other);
  
  // implements Message ----------------------------------------------
  
  BufferPacketMessage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sender_id = 1;
  inline bool has_sender_id() const;
  inline void clear_sender_id();
  inline const ::std::string& sender_id() const;
  inline void set_sender_id(const ::std::string& value);
  inline void set_sender_id(const char* value);
  inline ::std::string* mutable_sender_id();
  
  // optional string sender_public_key = 2;
  inline bool has_sender_public_key() const;
  inline void clear_sender_public_key();
  inline const ::std::string& sender_public_key() const;
  inline void set_sender_public_key(const ::std::string& value);
  inline void set_sender_public_key(const char* value);
  inline ::std::string* mutable_sender_public_key();
  
  // required string RSAenc_key = 3;
  inline bool has_rsaenc_key() const;
  inline void clear_rsaenc_key();
  inline const ::std::string& rsaenc_key() const;
  inline void set_rsaenc_key(const ::std::string& value);
  inline void set_rsaenc_key(const char* value);
  inline ::std::string* mutable_rsaenc_key();
  
  // required string AESenc_message = 4;
  inline bool has_aesenc_message() const;
  inline void clear_aesenc_message();
  inline const ::std::string& aesenc_message() const;
  inline void set_aesenc_message(const ::std::string& value);
  inline void set_aesenc_message(const char* value);
  inline ::std::string* mutable_aesenc_message();
  
  // required .packethandler.MessageType type = 5;
  inline bool has_type() const;
  inline void clear_type();
  inline packethandler::MessageType type() const;
  inline void set_type(packethandler::MessageType value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* sender_id_;
  static const ::std::string _default_sender_id_;
  ::std::string* sender_public_key_;
  static const ::std::string _default_sender_public_key_;
  ::std::string* rsaenc_key_;
  static const ::std::string _default_rsaenc_key_;
  ::std::string* aesenc_message_;
  static const ::std::string _default_aesenc_message_;
  int type_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BufferPacketMessage* default_instance_;
};
// -------------------------------------------------------------------

class BufferPacket : public ::google::protobuf::Message {
 public:
  BufferPacket();
  virtual ~BufferPacket();
  
  BufferPacket(const BufferPacket& from);
  
  inline BufferPacket& operator=(const BufferPacket& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferPacket& default_instance();
  void Swap(BufferPacket* other);
  
  // implements Message ----------------------------------------------
  
  BufferPacket* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .packethandler.GenericPacket owner_info = 1;
  inline int owner_info_size() const;
  inline void clear_owner_info();
  inline const ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >& owner_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >* mutable_owner_info();
  inline const ::packethandler::GenericPacket& owner_info(int index) const;
  inline ::packethandler::GenericPacket* mutable_owner_info(int index);
  inline ::packethandler::GenericPacket* add_owner_info();
  
  // repeated .packethandler.GenericPacket messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >& messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >* mutable_messages();
  inline const ::packethandler::GenericPacket& messages(int index) const;
  inline ::packethandler::GenericPacket* mutable_messages(int index);
  inline ::packethandler::GenericPacket* add_messages();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket > owner_info_;
  ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket > messages_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BufferPacket* default_instance_;
};
// -------------------------------------------------------------------

class ValidatedBufferPacketMessage : public ::google::protobuf::Message {
 public:
  ValidatedBufferPacketMessage();
  virtual ~ValidatedBufferPacketMessage();
  
  ValidatedBufferPacketMessage(const ValidatedBufferPacketMessage& from);
  
  inline ValidatedBufferPacketMessage& operator=(const ValidatedBufferPacketMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidatedBufferPacketMessage& default_instance();
  void Swap(ValidatedBufferPacketMessage* other);
  
  // implements Message ----------------------------------------------
  
  ValidatedBufferPacketMessage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline ::std::string* mutable_sender();
  
  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline ::std::string* mutable_message();
  
  // required string index = 3;
  inline bool has_index() const;
  inline void clear_index();
  inline const ::std::string& index() const;
  inline void set_index(const ::std::string& value);
  inline void set_index(const char* value);
  inline ::std::string* mutable_index();
  
  // required .packethandler.MessageType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  inline packethandler::MessageType type() const;
  inline void set_type(packethandler::MessageType value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* sender_;
  static const ::std::string _default_sender_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  ::std::string* index_;
  static const ::std::string _default_index_;
  int type_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ValidatedBufferPacketMessage* default_instance_;
};
// -------------------------------------------------------------------

class ContactInfo : public ::google::protobuf::Message {
 public:
  ContactInfo();
  virtual ~ContactInfo();
  
  ContactInfo(const ContactInfo& from);
  
  inline ContactInfo& operator=(const ContactInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactInfo& default_instance();
  void Swap(ContactInfo* other);
  
  // implements Message ----------------------------------------------
  
  ContactInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline ::std::string* mutable_name();
  
  // optional string birthday = 2;
  inline bool has_birthday() const;
  inline void clear_birthday();
  inline const ::std::string& birthday() const;
  inline void set_birthday(const ::std::string& value);
  inline void set_birthday(const char* value);
  inline ::std::string* mutable_birthday();
  
  // optional string office_number = 3;
  inline bool has_office_number() const;
  inline void clear_office_number();
  inline const ::std::string& office_number() const;
  inline void set_office_number(const ::std::string& value);
  inline void set_office_number(const char* value);
  inline ::std::string* mutable_office_number();
  
  // optional string gender = 4;
  inline bool has_gender() const;
  inline void clear_gender();
  inline const ::std::string& gender() const;
  inline void set_gender(const ::std::string& value);
  inline void set_gender(const char* value);
  inline ::std::string* mutable_gender();
  
  // optional int32 country = 5;
  inline bool has_country() const;
  inline void clear_country();
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);
  
  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline ::std::string* mutable_city();
  
  // optional int32 language = 7;
  inline bool has_language() const;
  inline void clear_language();
  inline ::google::protobuf::int32 language() const;
  inline void set_language(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* birthday_;
  static const ::std::string _default_birthday_;
  ::std::string* office_number_;
  static const ::std::string _default_office_number_;
  ::std::string* gender_;
  static const ::std::string _default_gender_;
  ::google::protobuf::int32 country_;
  ::std::string* city_;
  static const ::std::string _default_city_;
  ::google::protobuf::int32 language_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ContactInfo* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage : public ::google::protobuf::Message {
 public:
  InstantMessage();
  virtual ~InstantMessage();
  
  InstantMessage(const InstantMessage& from);
  
  inline InstantMessage& operator=(const InstantMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstantMessage& default_instance();
  void Swap(InstantMessage* other);
  
  // implements Message ----------------------------------------------
  
  InstantMessage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline ::std::string* mutable_sender();
  
  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline ::std::string* mutable_message();
  
  // required int32 date = 3;
  inline bool has_date() const;
  inline void clear_date();
  inline ::google::protobuf::int32 date() const;
  inline void set_date(::google::protobuf::int32 value);
  
  // required .packethandler.MessageType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  inline packethandler::MessageType type() const;
  inline void set_type(packethandler::MessageType value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* sender_;
  static const ::std::string _default_sender_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  ::google::protobuf::int32 date_;
  int type_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static InstantMessage* default_instance_;
};
// -------------------------------------------------------------------

class InstantFileMessage : public ::google::protobuf::Message {
 public:
  InstantFileMessage();
  virtual ~InstantFileMessage();
  
  InstantFileMessage(const InstantFileMessage& from);
  
  inline InstantFileMessage& operator=(const InstantFileMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstantFileMessage& default_instance();
  void Swap(InstantFileMessage* other);
  
  // implements Message ----------------------------------------------
  
  InstantFileMessage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ser_mdm = 1;
  inline bool has_ser_mdm() const;
  inline void clear_ser_mdm();
  inline const ::std::string& ser_mdm() const;
  inline void set_ser_mdm(const ::std::string& value);
  inline void set_ser_mdm(const char* value);
  inline ::std::string* mutable_ser_mdm();
  
  // required string ser_dm = 2;
  inline bool has_ser_dm() const;
  inline void clear_ser_dm();
  inline const ::std::string& ser_dm() const;
  inline void set_ser_dm(const ::std::string& value);
  inline void set_ser_dm(const char* value);
  inline ::std::string* mutable_ser_dm();
  
  // required string filename = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline ::std::string* mutable_filename();
  
  // optional string sender_msg = 4;
  inline bool has_sender_msg() const;
  inline void clear_sender_msg();
  inline const ::std::string& sender_msg() const;
  inline void set_sender_msg(const ::std::string& value);
  inline void set_sender_msg(const char* value);
  inline ::std::string* mutable_sender_msg();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* ser_mdm_;
  static const ::std::string _default_ser_mdm_;
  ::std::string* ser_dm_;
  static const ::std::string _default_ser_dm_;
  ::std::string* filename_;
  static const ::std::string _default_filename_;
  ::std::string* sender_msg_;
  static const ::std::string _default_sender_msg_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static InstantFileMessage* default_instance_;
};
// -------------------------------------------------------------------

class StoreMessagesResult : public ::google::protobuf::Message {
 public:
  StoreMessagesResult();
  virtual ~StoreMessagesResult();
  
  StoreMessagesResult(const StoreMessagesResult& from);
  
  inline StoreMessagesResult& operator=(const StoreMessagesResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreMessagesResult& default_instance();
  void Swap(StoreMessagesResult* other);
  
  // implements Message ----------------------------------------------
  
  StoreMessagesResult* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline ::std::string* mutable_result();
  
  // required int32 stored_msgs = 2;
  inline bool has_stored_msgs() const;
  inline void clear_stored_msgs();
  inline ::google::protobuf::int32 stored_msgs() const;
  inline void set_stored_msgs(::google::protobuf::int32 value);
  
  // repeated string failed = 3;
  inline int failed_size() const;
  inline void clear_failed();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& failed() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_failed();
  inline const ::std::string& failed(int index) const;
  inline ::std::string* mutable_failed(int index);
  inline void set_failed(int index, const ::std::string& value);
  inline void set_failed(int index, const char* value);
  inline ::std::string* add_failed();
  inline void add_failed(const ::std::string& value);
  inline void add_failed(const char* value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::google::protobuf::int32 stored_msgs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> failed_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreMessagesResult* default_instance_;
};
// -------------------------------------------------------------------

class CreateMSIDResult : public ::google::protobuf::Message {
 public:
  CreateMSIDResult();
  virtual ~CreateMSIDResult();
  
  CreateMSIDResult(const CreateMSIDResult& from);
  
  inline CreateMSIDResult& operator=(const CreateMSIDResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateMSIDResult& default_instance();
  void Swap(CreateMSIDResult* other);
  
  // implements Message ----------------------------------------------
  
  CreateMSIDResult* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline ::std::string* mutable_result();
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline ::std::string* mutable_name();
  
  // optional string private_key = 3;
  inline bool has_private_key() const;
  inline void clear_private_key();
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline ::std::string* mutable_private_key();
  
  // optional string public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline ::std::string* mutable_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* private_key_;
  static const ::std::string _default_private_key_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CreateMSIDResult* default_instance_;
};
// -------------------------------------------------------------------

class PrivateShareNotification : public ::google::protobuf::Message {
 public:
  PrivateShareNotification();
  virtual ~PrivateShareNotification();
  
  PrivateShareNotification(const PrivateShareNotification& from);
  
  inline PrivateShareNotification& operator=(const PrivateShareNotification& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateShareNotification& default_instance();
  void Swap(PrivateShareNotification* other);
  
  // implements Message ----------------------------------------------
  
  PrivateShareNotification* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline ::std::string* mutable_name();
  
  // required string msid = 2;
  inline bool has_msid() const;
  inline void clear_msid();
  inline const ::std::string& msid() const;
  inline void set_msid(const ::std::string& value);
  inline void set_msid(const char* value);
  inline ::std::string* mutable_msid();
  
  // required string public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline ::std::string* mutable_public_key();
  
  // optional string private_key = 4;
  inline bool has_private_key() const;
  inline void clear_private_key();
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline ::std::string* mutable_private_key();
  
  // repeated string admins = 5;
  inline int admins_size() const;
  inline void clear_admins();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& admins() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_admins();
  inline const ::std::string& admins(int index) const;
  inline ::std::string* mutable_admins(int index);
  inline void set_admins(int index, const ::std::string& value);
  inline void set_admins(int index, const char* value);
  inline ::std::string* add_admins();
  inline void add_admins(const ::std::string& value);
  inline void add_admins(const char* value);
  
  // repeated string readonlys = 6;
  inline int readonlys_size() const;
  inline void clear_readonlys();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& readonlys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_readonlys();
  inline const ::std::string& readonlys(int index) const;
  inline ::std::string* mutable_readonlys(int index);
  inline void set_readonlys(int index, const ::std::string& value);
  inline void set_readonlys(int index, const char* value);
  inline ::std::string* add_readonlys();
  inline void add_readonlys(const ::std::string& value);
  inline void add_readonlys(const char* value);
  
  // required string dir_db_key = 7;
  inline bool has_dir_db_key() const;
  inline void clear_dir_db_key();
  inline const ::std::string& dir_db_key() const;
  inline void set_dir_db_key(const ::std::string& value);
  inline void set_dir_db_key(const char* value);
  inline ::std::string* mutable_dir_db_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* msid_;
  static const ::std::string _default_msid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* private_key_;
  static const ::std::string _default_private_key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> admins_;
  ::google::protobuf::RepeatedPtrField< ::std::string> readonlys_;
  ::std::string* dir_db_key_;
  static const ::std::string _default_dir_db_key_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PrivateShareNotification* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// GenericPacket

// required string data = 1;
inline bool GenericPacket::has_data() const {
  return _has_bit(0);
}
inline void GenericPacket::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GenericPacket::data() const {
  return *data_;
}
inline void GenericPacket::set_data(const ::std::string& value) {
  _set_bit(0);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GenericPacket::set_data(const char* value) {
  _set_bit(0);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline ::std::string* GenericPacket::mutable_data() {
  _set_bit(0);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// required string signature = 2;
inline bool GenericPacket::has_signature() const {
  return _has_bit(1);
}
inline void GenericPacket::clear_signature() {
  if (signature_ != &_default_signature_) {
    signature_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GenericPacket::signature() const {
  return *signature_;
}
inline void GenericPacket::set_signature(const ::std::string& value) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void GenericPacket::set_signature(const char* value) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline ::std::string* GenericPacket::mutable_signature() {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  return signature_;
}

// -------------------------------------------------------------------

// BufferPacketInfo

// required string owner = 1;
inline bool BufferPacketInfo::has_owner() const {
  return _has_bit(0);
}
inline void BufferPacketInfo::clear_owner() {
  if (owner_ != &_default_owner_) {
    owner_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BufferPacketInfo::owner() const {
  return *owner_;
}
inline void BufferPacketInfo::set_owner(const ::std::string& value) {
  _set_bit(0);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void BufferPacketInfo::set_owner(const char* value) {
  _set_bit(0);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline ::std::string* BufferPacketInfo::mutable_owner() {
  _set_bit(0);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  return owner_;
}

// required string ownerPublicKey = 2;
inline bool BufferPacketInfo::has_ownerpublickey() const {
  return _has_bit(1);
}
inline void BufferPacketInfo::clear_ownerpublickey() {
  if (ownerpublickey_ != &_default_ownerpublickey_) {
    ownerpublickey_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& BufferPacketInfo::ownerpublickey() const {
  return *ownerpublickey_;
}
inline void BufferPacketInfo::set_ownerpublickey(const ::std::string& value) {
  _set_bit(1);
  if (ownerpublickey_ == &_default_ownerpublickey_) {
    ownerpublickey_ = new ::std::string;
  }
  ownerpublickey_->assign(value);
}
inline void BufferPacketInfo::set_ownerpublickey(const char* value) {
  _set_bit(1);
  if (ownerpublickey_ == &_default_ownerpublickey_) {
    ownerpublickey_ = new ::std::string;
  }
  ownerpublickey_->assign(value);
}
inline ::std::string* BufferPacketInfo::mutable_ownerpublickey() {
  _set_bit(1);
  if (ownerpublickey_ == &_default_ownerpublickey_) {
    ownerpublickey_ = new ::std::string;
  }
  return ownerpublickey_;
}

// repeated string users = 3;
inline int BufferPacketInfo::users_size() const {
  return users_.size();
}
inline void BufferPacketInfo::clear_users() {
  users_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BufferPacketInfo::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BufferPacketInfo::mutable_users() {
  return &users_;
}
inline const ::std::string& BufferPacketInfo::users(int index) const {
  return users_.Get(index);
}
inline ::std::string* BufferPacketInfo::mutable_users(int index) {
  return users_.Mutable(index);
}
inline void BufferPacketInfo::set_users(int index, const ::std::string& value) {
  users_.Mutable(index)->assign(value);
}
inline void BufferPacketInfo::set_users(int index, const char* value) {
  users_.Mutable(index)->assign(value);
}
inline ::std::string* BufferPacketInfo::add_users() {
  return users_.Add();
}
inline void BufferPacketInfo::add_users(const ::std::string& value) {
  users_.Add()->assign(value);
}
inline void BufferPacketInfo::add_users(const char* value) {
  users_.Add()->assign(value);
}

// optional bool online = 4;
inline bool BufferPacketInfo::has_online() const {
  return _has_bit(3);
}
inline void BufferPacketInfo::clear_online() {
  online_ = false;
  _clear_bit(3);
}
inline bool BufferPacketInfo::online() const {
  return online_;
}
inline void BufferPacketInfo::set_online(bool value) {
  _set_bit(3);
  online_ = value;
}

// -------------------------------------------------------------------

// BufferPacketMessage

// required string sender_id = 1;
inline bool BufferPacketMessage::has_sender_id() const {
  return _has_bit(0);
}
inline void BufferPacketMessage::clear_sender_id() {
  if (sender_id_ != &_default_sender_id_) {
    sender_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BufferPacketMessage::sender_id() const {
  return *sender_id_;
}
inline void BufferPacketMessage::set_sender_id(const ::std::string& value) {
  _set_bit(0);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(value);
}
inline void BufferPacketMessage::set_sender_id(const char* value) {
  _set_bit(0);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(value);
}
inline ::std::string* BufferPacketMessage::mutable_sender_id() {
  _set_bit(0);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  return sender_id_;
}

// optional string sender_public_key = 2;
inline bool BufferPacketMessage::has_sender_public_key() const {
  return _has_bit(1);
}
inline void BufferPacketMessage::clear_sender_public_key() {
  if (sender_public_key_ != &_default_sender_public_key_) {
    sender_public_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& BufferPacketMessage::sender_public_key() const {
  return *sender_public_key_;
}
inline void BufferPacketMessage::set_sender_public_key(const ::std::string& value) {
  _set_bit(1);
  if (sender_public_key_ == &_default_sender_public_key_) {
    sender_public_key_ = new ::std::string;
  }
  sender_public_key_->assign(value);
}
inline void BufferPacketMessage::set_sender_public_key(const char* value) {
  _set_bit(1);
  if (sender_public_key_ == &_default_sender_public_key_) {
    sender_public_key_ = new ::std::string;
  }
  sender_public_key_->assign(value);
}
inline ::std::string* BufferPacketMessage::mutable_sender_public_key() {
  _set_bit(1);
  if (sender_public_key_ == &_default_sender_public_key_) {
    sender_public_key_ = new ::std::string;
  }
  return sender_public_key_;
}

// required string RSAenc_key = 3;
inline bool BufferPacketMessage::has_rsaenc_key() const {
  return _has_bit(2);
}
inline void BufferPacketMessage::clear_rsaenc_key() {
  if (rsaenc_key_ != &_default_rsaenc_key_) {
    rsaenc_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& BufferPacketMessage::rsaenc_key() const {
  return *rsaenc_key_;
}
inline void BufferPacketMessage::set_rsaenc_key(const ::std::string& value) {
  _set_bit(2);
  if (rsaenc_key_ == &_default_rsaenc_key_) {
    rsaenc_key_ = new ::std::string;
  }
  rsaenc_key_->assign(value);
}
inline void BufferPacketMessage::set_rsaenc_key(const char* value) {
  _set_bit(2);
  if (rsaenc_key_ == &_default_rsaenc_key_) {
    rsaenc_key_ = new ::std::string;
  }
  rsaenc_key_->assign(value);
}
inline ::std::string* BufferPacketMessage::mutable_rsaenc_key() {
  _set_bit(2);
  if (rsaenc_key_ == &_default_rsaenc_key_) {
    rsaenc_key_ = new ::std::string;
  }
  return rsaenc_key_;
}

// required string AESenc_message = 4;
inline bool BufferPacketMessage::has_aesenc_message() const {
  return _has_bit(3);
}
inline void BufferPacketMessage::clear_aesenc_message() {
  if (aesenc_message_ != &_default_aesenc_message_) {
    aesenc_message_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& BufferPacketMessage::aesenc_message() const {
  return *aesenc_message_;
}
inline void BufferPacketMessage::set_aesenc_message(const ::std::string& value) {
  _set_bit(3);
  if (aesenc_message_ == &_default_aesenc_message_) {
    aesenc_message_ = new ::std::string;
  }
  aesenc_message_->assign(value);
}
inline void BufferPacketMessage::set_aesenc_message(const char* value) {
  _set_bit(3);
  if (aesenc_message_ == &_default_aesenc_message_) {
    aesenc_message_ = new ::std::string;
  }
  aesenc_message_->assign(value);
}
inline ::std::string* BufferPacketMessage::mutable_aesenc_message() {
  _set_bit(3);
  if (aesenc_message_ == &_default_aesenc_message_) {
    aesenc_message_ = new ::std::string;
  }
  return aesenc_message_;
}

// required .packethandler.MessageType type = 5;
inline bool BufferPacketMessage::has_type() const {
  return _has_bit(4);
}
inline void BufferPacketMessage::clear_type() {
  type_ = 0;
  _clear_bit(4);
}
inline packethandler::MessageType BufferPacketMessage::type() const {
  return static_cast< packethandler::MessageType >(type_);
}
inline void BufferPacketMessage::set_type(packethandler::MessageType value) {
  GOOGLE_DCHECK(packethandler::MessageType_IsValid(value));
  _set_bit(4);
  type_ = value;
}

// -------------------------------------------------------------------

// BufferPacket

// repeated .packethandler.GenericPacket owner_info = 1;
inline int BufferPacket::owner_info_size() const {
  return owner_info_.size();
}
inline void BufferPacket::clear_owner_info() {
  owner_info_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >&
BufferPacket::owner_info() const {
  return owner_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >*
BufferPacket::mutable_owner_info() {
  return &owner_info_;
}
inline const ::packethandler::GenericPacket& BufferPacket::owner_info(int index) const {
  return owner_info_.Get(index);
}
inline ::packethandler::GenericPacket* BufferPacket::mutable_owner_info(int index) {
  return owner_info_.Mutable(index);
}
inline ::packethandler::GenericPacket* BufferPacket::add_owner_info() {
  return owner_info_.Add();
}

// repeated .packethandler.GenericPacket messages = 2;
inline int BufferPacket::messages_size() const {
  return messages_.size();
}
inline void BufferPacket::clear_messages() {
  messages_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >&
BufferPacket::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >*
BufferPacket::mutable_messages() {
  return &messages_;
}
inline const ::packethandler::GenericPacket& BufferPacket::messages(int index) const {
  return messages_.Get(index);
}
inline ::packethandler::GenericPacket* BufferPacket::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline ::packethandler::GenericPacket* BufferPacket::add_messages() {
  return messages_.Add();
}

// -------------------------------------------------------------------

// ValidatedBufferPacketMessage

// required string sender = 1;
inline bool ValidatedBufferPacketMessage::has_sender() const {
  return _has_bit(0);
}
inline void ValidatedBufferPacketMessage::clear_sender() {
  if (sender_ != &_default_sender_) {
    sender_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ValidatedBufferPacketMessage::sender() const {
  return *sender_;
}
inline void ValidatedBufferPacketMessage::set_sender(const ::std::string& value) {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void ValidatedBufferPacketMessage::set_sender(const char* value) {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline ::std::string* ValidatedBufferPacketMessage::mutable_sender() {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  return sender_;
}

// required string message = 2;
inline bool ValidatedBufferPacketMessage::has_message() const {
  return _has_bit(1);
}
inline void ValidatedBufferPacketMessage::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ValidatedBufferPacketMessage::message() const {
  return *message_;
}
inline void ValidatedBufferPacketMessage::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ValidatedBufferPacketMessage::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline ::std::string* ValidatedBufferPacketMessage::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// required string index = 3;
inline bool ValidatedBufferPacketMessage::has_index() const {
  return _has_bit(2);
}
inline void ValidatedBufferPacketMessage::clear_index() {
  if (index_ != &_default_index_) {
    index_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ValidatedBufferPacketMessage::index() const {
  return *index_;
}
inline void ValidatedBufferPacketMessage::set_index(const ::std::string& value) {
  _set_bit(2);
  if (index_ == &_default_index_) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void ValidatedBufferPacketMessage::set_index(const char* value) {
  _set_bit(2);
  if (index_ == &_default_index_) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline ::std::string* ValidatedBufferPacketMessage::mutable_index() {
  _set_bit(2);
  if (index_ == &_default_index_) {
    index_ = new ::std::string;
  }
  return index_;
}

// required .packethandler.MessageType type = 4;
inline bool ValidatedBufferPacketMessage::has_type() const {
  return _has_bit(3);
}
inline void ValidatedBufferPacketMessage::clear_type() {
  type_ = 0;
  _clear_bit(3);
}
inline packethandler::MessageType ValidatedBufferPacketMessage::type() const {
  return static_cast< packethandler::MessageType >(type_);
}
inline void ValidatedBufferPacketMessage::set_type(packethandler::MessageType value) {
  GOOGLE_DCHECK(packethandler::MessageType_IsValid(value));
  _set_bit(3);
  type_ = value;
}

// -------------------------------------------------------------------

// ContactInfo

// optional string name = 1;
inline bool ContactInfo::has_name() const {
  return _has_bit(0);
}
inline void ContactInfo::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ContactInfo::name() const {
  return *name_;
}
inline void ContactInfo::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ContactInfo::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline ::std::string* ContactInfo::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string birthday = 2;
inline bool ContactInfo::has_birthday() const {
  return _has_bit(1);
}
inline void ContactInfo::clear_birthday() {
  if (birthday_ != &_default_birthday_) {
    birthday_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ContactInfo::birthday() const {
  return *birthday_;
}
inline void ContactInfo::set_birthday(const ::std::string& value) {
  _set_bit(1);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void ContactInfo::set_birthday(const char* value) {
  _set_bit(1);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline ::std::string* ContactInfo::mutable_birthday() {
  _set_bit(1);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  return birthday_;
}

// optional string office_number = 3;
inline bool ContactInfo::has_office_number() const {
  return _has_bit(2);
}
inline void ContactInfo::clear_office_number() {
  if (office_number_ != &_default_office_number_) {
    office_number_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ContactInfo::office_number() const {
  return *office_number_;
}
inline void ContactInfo::set_office_number(const ::std::string& value) {
  _set_bit(2);
  if (office_number_ == &_default_office_number_) {
    office_number_ = new ::std::string;
  }
  office_number_->assign(value);
}
inline void ContactInfo::set_office_number(const char* value) {
  _set_bit(2);
  if (office_number_ == &_default_office_number_) {
    office_number_ = new ::std::string;
  }
  office_number_->assign(value);
}
inline ::std::string* ContactInfo::mutable_office_number() {
  _set_bit(2);
  if (office_number_ == &_default_office_number_) {
    office_number_ = new ::std::string;
  }
  return office_number_;
}

// optional string gender = 4;
inline bool ContactInfo::has_gender() const {
  return _has_bit(3);
}
inline void ContactInfo::clear_gender() {
  if (gender_ != &_default_gender_) {
    gender_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& ContactInfo::gender() const {
  return *gender_;
}
inline void ContactInfo::set_gender(const ::std::string& value) {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void ContactInfo::set_gender(const char* value) {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline ::std::string* ContactInfo::mutable_gender() {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  return gender_;
}

// optional int32 country = 5;
inline bool ContactInfo::has_country() const {
  return _has_bit(4);
}
inline void ContactInfo::clear_country() {
  country_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 ContactInfo::country() const {
  return country_;
}
inline void ContactInfo::set_country(::google::protobuf::int32 value) {
  _set_bit(4);
  country_ = value;
}

// optional string city = 6;
inline bool ContactInfo::has_city() const {
  return _has_bit(5);
}
inline void ContactInfo::clear_city() {
  if (city_ != &_default_city_) {
    city_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& ContactInfo::city() const {
  return *city_;
}
inline void ContactInfo::set_city(const ::std::string& value) {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void ContactInfo::set_city(const char* value) {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline ::std::string* ContactInfo::mutable_city() {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  return city_;
}

// optional int32 language = 7;
inline bool ContactInfo::has_language() const {
  return _has_bit(6);
}
inline void ContactInfo::clear_language() {
  language_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 ContactInfo::language() const {
  return language_;
}
inline void ContactInfo::set_language(::google::protobuf::int32 value) {
  _set_bit(6);
  language_ = value;
}

// -------------------------------------------------------------------

// InstantMessage

// required string sender = 1;
inline bool InstantMessage::has_sender() const {
  return _has_bit(0);
}
inline void InstantMessage::clear_sender() {
  if (sender_ != &_default_sender_) {
    sender_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& InstantMessage::sender() const {
  return *sender_;
}
inline void InstantMessage::set_sender(const ::std::string& value) {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void InstantMessage::set_sender(const char* value) {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline ::std::string* InstantMessage::mutable_sender() {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  return sender_;
}

// required string message = 2;
inline bool InstantMessage::has_message() const {
  return _has_bit(1);
}
inline void InstantMessage::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& InstantMessage::message() const {
  return *message_;
}
inline void InstantMessage::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void InstantMessage::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline ::std::string* InstantMessage::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// required int32 date = 3;
inline bool InstantMessage::has_date() const {
  return _has_bit(2);
}
inline void InstantMessage::clear_date() {
  date_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 InstantMessage::date() const {
  return date_;
}
inline void InstantMessage::set_date(::google::protobuf::int32 value) {
  _set_bit(2);
  date_ = value;
}

// required .packethandler.MessageType type = 4;
inline bool InstantMessage::has_type() const {
  return _has_bit(3);
}
inline void InstantMessage::clear_type() {
  type_ = 0;
  _clear_bit(3);
}
inline packethandler::MessageType InstantMessage::type() const {
  return static_cast< packethandler::MessageType >(type_);
}
inline void InstantMessage::set_type(packethandler::MessageType value) {
  GOOGLE_DCHECK(packethandler::MessageType_IsValid(value));
  _set_bit(3);
  type_ = value;
}

// -------------------------------------------------------------------

// InstantFileMessage

// required string ser_mdm = 1;
inline bool InstantFileMessage::has_ser_mdm() const {
  return _has_bit(0);
}
inline void InstantFileMessage::clear_ser_mdm() {
  if (ser_mdm_ != &_default_ser_mdm_) {
    ser_mdm_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& InstantFileMessage::ser_mdm() const {
  return *ser_mdm_;
}
inline void InstantFileMessage::set_ser_mdm(const ::std::string& value) {
  _set_bit(0);
  if (ser_mdm_ == &_default_ser_mdm_) {
    ser_mdm_ = new ::std::string;
  }
  ser_mdm_->assign(value);
}
inline void InstantFileMessage::set_ser_mdm(const char* value) {
  _set_bit(0);
  if (ser_mdm_ == &_default_ser_mdm_) {
    ser_mdm_ = new ::std::string;
  }
  ser_mdm_->assign(value);
}
inline ::std::string* InstantFileMessage::mutable_ser_mdm() {
  _set_bit(0);
  if (ser_mdm_ == &_default_ser_mdm_) {
    ser_mdm_ = new ::std::string;
  }
  return ser_mdm_;
}

// required string ser_dm = 2;
inline bool InstantFileMessage::has_ser_dm() const {
  return _has_bit(1);
}
inline void InstantFileMessage::clear_ser_dm() {
  if (ser_dm_ != &_default_ser_dm_) {
    ser_dm_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& InstantFileMessage::ser_dm() const {
  return *ser_dm_;
}
inline void InstantFileMessage::set_ser_dm(const ::std::string& value) {
  _set_bit(1);
  if (ser_dm_ == &_default_ser_dm_) {
    ser_dm_ = new ::std::string;
  }
  ser_dm_->assign(value);
}
inline void InstantFileMessage::set_ser_dm(const char* value) {
  _set_bit(1);
  if (ser_dm_ == &_default_ser_dm_) {
    ser_dm_ = new ::std::string;
  }
  ser_dm_->assign(value);
}
inline ::std::string* InstantFileMessage::mutable_ser_dm() {
  _set_bit(1);
  if (ser_dm_ == &_default_ser_dm_) {
    ser_dm_ = new ::std::string;
  }
  return ser_dm_;
}

// required string filename = 3;
inline bool InstantFileMessage::has_filename() const {
  return _has_bit(2);
}
inline void InstantFileMessage::clear_filename() {
  if (filename_ != &_default_filename_) {
    filename_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& InstantFileMessage::filename() const {
  return *filename_;
}
inline void InstantFileMessage::set_filename(const ::std::string& value) {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void InstantFileMessage::set_filename(const char* value) {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline ::std::string* InstantFileMessage::mutable_filename() {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  return filename_;
}

// optional string sender_msg = 4;
inline bool InstantFileMessage::has_sender_msg() const {
  return _has_bit(3);
}
inline void InstantFileMessage::clear_sender_msg() {
  if (sender_msg_ != &_default_sender_msg_) {
    sender_msg_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& InstantFileMessage::sender_msg() const {
  return *sender_msg_;
}
inline void InstantFileMessage::set_sender_msg(const ::std::string& value) {
  _set_bit(3);
  if (sender_msg_ == &_default_sender_msg_) {
    sender_msg_ = new ::std::string;
  }
  sender_msg_->assign(value);
}
inline void InstantFileMessage::set_sender_msg(const char* value) {
  _set_bit(3);
  if (sender_msg_ == &_default_sender_msg_) {
    sender_msg_ = new ::std::string;
  }
  sender_msg_->assign(value);
}
inline ::std::string* InstantFileMessage::mutable_sender_msg() {
  _set_bit(3);
  if (sender_msg_ == &_default_sender_msg_) {
    sender_msg_ = new ::std::string;
  }
  return sender_msg_;
}

// -------------------------------------------------------------------

// StoreMessagesResult

// required string result = 1;
inline bool StoreMessagesResult::has_result() const {
  return _has_bit(0);
}
inline void StoreMessagesResult::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StoreMessagesResult::result() const {
  return *result_;
}
inline void StoreMessagesResult::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void StoreMessagesResult::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline ::std::string* StoreMessagesResult::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// required int32 stored_msgs = 2;
inline bool StoreMessagesResult::has_stored_msgs() const {
  return _has_bit(1);
}
inline void StoreMessagesResult::clear_stored_msgs() {
  stored_msgs_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 StoreMessagesResult::stored_msgs() const {
  return stored_msgs_;
}
inline void StoreMessagesResult::set_stored_msgs(::google::protobuf::int32 value) {
  _set_bit(1);
  stored_msgs_ = value;
}

// repeated string failed = 3;
inline int StoreMessagesResult::failed_size() const {
  return failed_.size();
}
inline void StoreMessagesResult::clear_failed() {
  failed_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StoreMessagesResult::failed() const {
  return failed_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StoreMessagesResult::mutable_failed() {
  return &failed_;
}
inline const ::std::string& StoreMessagesResult::failed(int index) const {
  return failed_.Get(index);
}
inline ::std::string* StoreMessagesResult::mutable_failed(int index) {
  return failed_.Mutable(index);
}
inline void StoreMessagesResult::set_failed(int index, const ::std::string& value) {
  failed_.Mutable(index)->assign(value);
}
inline void StoreMessagesResult::set_failed(int index, const char* value) {
  failed_.Mutable(index)->assign(value);
}
inline ::std::string* StoreMessagesResult::add_failed() {
  return failed_.Add();
}
inline void StoreMessagesResult::add_failed(const ::std::string& value) {
  failed_.Add()->assign(value);
}
inline void StoreMessagesResult::add_failed(const char* value) {
  failed_.Add()->assign(value);
}

// -------------------------------------------------------------------

// CreateMSIDResult

// required string result = 1;
inline bool CreateMSIDResult::has_result() const {
  return _has_bit(0);
}
inline void CreateMSIDResult::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CreateMSIDResult::result() const {
  return *result_;
}
inline void CreateMSIDResult::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void CreateMSIDResult::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline ::std::string* CreateMSIDResult::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional string name = 2;
inline bool CreateMSIDResult::has_name() const {
  return _has_bit(1);
}
inline void CreateMSIDResult::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CreateMSIDResult::name() const {
  return *name_;
}
inline void CreateMSIDResult::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateMSIDResult::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline ::std::string* CreateMSIDResult::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string private_key = 3;
inline bool CreateMSIDResult::has_private_key() const {
  return _has_bit(2);
}
inline void CreateMSIDResult::clear_private_key() {
  if (private_key_ != &_default_private_key_) {
    private_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CreateMSIDResult::private_key() const {
  return *private_key_;
}
inline void CreateMSIDResult::set_private_key(const ::std::string& value) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void CreateMSIDResult::set_private_key(const char* value) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline ::std::string* CreateMSIDResult::mutable_private_key() {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}

// optional string public_key = 4;
inline bool CreateMSIDResult::has_public_key() const {
  return _has_bit(3);
}
inline void CreateMSIDResult::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& CreateMSIDResult::public_key() const {
  return *public_key_;
}
inline void CreateMSIDResult::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void CreateMSIDResult::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline ::std::string* CreateMSIDResult::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// -------------------------------------------------------------------

// PrivateShareNotification

// required string name = 1;
inline bool PrivateShareNotification::has_name() const {
  return _has_bit(0);
}
inline void PrivateShareNotification::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PrivateShareNotification::name() const {
  return *name_;
}
inline void PrivateShareNotification::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PrivateShareNotification::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline ::std::string* PrivateShareNotification::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string msid = 2;
inline bool PrivateShareNotification::has_msid() const {
  return _has_bit(1);
}
inline void PrivateShareNotification::clear_msid() {
  if (msid_ != &_default_msid_) {
    msid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& PrivateShareNotification::msid() const {
  return *msid_;
}
inline void PrivateShareNotification::set_msid(const ::std::string& value) {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  msid_->assign(value);
}
inline void PrivateShareNotification::set_msid(const char* value) {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  msid_->assign(value);
}
inline ::std::string* PrivateShareNotification::mutable_msid() {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  return msid_;
}

// required string public_key = 3;
inline bool PrivateShareNotification::has_public_key() const {
  return _has_bit(2);
}
inline void PrivateShareNotification::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& PrivateShareNotification::public_key() const {
  return *public_key_;
}
inline void PrivateShareNotification::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void PrivateShareNotification::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline ::std::string* PrivateShareNotification::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional string private_key = 4;
inline bool PrivateShareNotification::has_private_key() const {
  return _has_bit(3);
}
inline void PrivateShareNotification::clear_private_key() {
  if (private_key_ != &_default_private_key_) {
    private_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& PrivateShareNotification::private_key() const {
  return *private_key_;
}
inline void PrivateShareNotification::set_private_key(const ::std::string& value) {
  _set_bit(3);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void PrivateShareNotification::set_private_key(const char* value) {
  _set_bit(3);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline ::std::string* PrivateShareNotification::mutable_private_key() {
  _set_bit(3);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}

// repeated string admins = 5;
inline int PrivateShareNotification::admins_size() const {
  return admins_.size();
}
inline void PrivateShareNotification::clear_admins() {
  admins_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrivateShareNotification::admins() const {
  return admins_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrivateShareNotification::mutable_admins() {
  return &admins_;
}
inline const ::std::string& PrivateShareNotification::admins(int index) const {
  return admins_.Get(index);
}
inline ::std::string* PrivateShareNotification::mutable_admins(int index) {
  return admins_.Mutable(index);
}
inline void PrivateShareNotification::set_admins(int index, const ::std::string& value) {
  admins_.Mutable(index)->assign(value);
}
inline void PrivateShareNotification::set_admins(int index, const char* value) {
  admins_.Mutable(index)->assign(value);
}
inline ::std::string* PrivateShareNotification::add_admins() {
  return admins_.Add();
}
inline void PrivateShareNotification::add_admins(const ::std::string& value) {
  admins_.Add()->assign(value);
}
inline void PrivateShareNotification::add_admins(const char* value) {
  admins_.Add()->assign(value);
}

// repeated string readonlys = 6;
inline int PrivateShareNotification::readonlys_size() const {
  return readonlys_.size();
}
inline void PrivateShareNotification::clear_readonlys() {
  readonlys_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrivateShareNotification::readonlys() const {
  return readonlys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrivateShareNotification::mutable_readonlys() {
  return &readonlys_;
}
inline const ::std::string& PrivateShareNotification::readonlys(int index) const {
  return readonlys_.Get(index);
}
inline ::std::string* PrivateShareNotification::mutable_readonlys(int index) {
  return readonlys_.Mutable(index);
}
inline void PrivateShareNotification::set_readonlys(int index, const ::std::string& value) {
  readonlys_.Mutable(index)->assign(value);
}
inline void PrivateShareNotification::set_readonlys(int index, const char* value) {
  readonlys_.Mutable(index)->assign(value);
}
inline ::std::string* PrivateShareNotification::add_readonlys() {
  return readonlys_.Add();
}
inline void PrivateShareNotification::add_readonlys(const ::std::string& value) {
  readonlys_.Add()->assign(value);
}
inline void PrivateShareNotification::add_readonlys(const char* value) {
  readonlys_.Add()->assign(value);
}

// required string dir_db_key = 7;
inline bool PrivateShareNotification::has_dir_db_key() const {
  return _has_bit(6);
}
inline void PrivateShareNotification::clear_dir_db_key() {
  if (dir_db_key_ != &_default_dir_db_key_) {
    dir_db_key_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& PrivateShareNotification::dir_db_key() const {
  return *dir_db_key_;
}
inline void PrivateShareNotification::set_dir_db_key(const ::std::string& value) {
  _set_bit(6);
  if (dir_db_key_ == &_default_dir_db_key_) {
    dir_db_key_ = new ::std::string;
  }
  dir_db_key_->assign(value);
}
inline void PrivateShareNotification::set_dir_db_key(const char* value) {
  _set_bit(6);
  if (dir_db_key_ == &_default_dir_db_key_) {
    dir_db_key_ = new ::std::string;
  }
  dir_db_key_->assign(value);
}
inline ::std::string* PrivateShareNotification::mutable_dir_db_key() {
  _set_bit(6);
  if (dir_db_key_ == &_default_dir_db_key_) {
    dir_db_key_ = new ::std::string;
  }
  return dir_db_key_;
}


}  // namespace packethandler
#endif  // PROTOBUF_packet_2eproto__INCLUDED
